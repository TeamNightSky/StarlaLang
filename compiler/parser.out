Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     statement -> if
Rule 4     statement -> vardecl
Rule 5     statement -> funcdecl
Rule 6     statement -> whileloop
Rule 7     statement -> forloop
Rule 8     gt -> GT
Rule 9     ge -> GE
Rule 10    lt -> LT
Rule 11    le -> LE
Rule 12    ne -> NE
Rule 13    eq -> EQ
Rule 14    comparator -> gt
Rule 15    comparator -> ge
Rule 16    comparator -> lt
Rule 17    comparator -> le
Rule 18    comparator -> ne
Rule 19    comparator -> eq
Rule 20    condition -> condition comparator expression
Rule 21    condition -> LPAREN condition RPAREN
Rule 22    condition -> expression
Rule 23    condition -> condition AND condition
Rule 24    condition -> condition OR condition
Rule 25    condition -> condition XOR condition
Rule 26    condition -> NOT condition
Rule 27    if -> IF condition LBRACE program RBRACE
Rule 28    if -> IF condition LIKELY BOOL LBRACE program RBRACE
Rule 29    if -> if ELIF condition LBRACE program RBRACE
Rule 30    if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE
Rule 31    if -> if ELSE LBRACE program RBRACE
Rule 32    item -> object COLON object
Rule 33    items -> items SEPARATOR item
Rule 34    items -> item
Rule 35    elements -> elements SEPARATOR object
Rule 36    elements -> object
Rule 37    dict -> LBRACE items RBRACE
Rule 38    list -> LBRACKET elements RBRACKET
Rule 39    tuple -> LPAREN elements RPAREN
Rule 40    object -> dict
Rule 41    object -> list
Rule 42    object -> tuple
Rule 43    object -> int
Rule 44    object -> float
Rule 45    object -> double
Rule 46    object -> string
Rule 47    object -> char
Rule 48    object -> bool
Rule 49    object -> null
Rule 50    object -> namespace
Rule 51    object -> funccall
Rule 52    namespace -> NAMESPACE
Rule 53    int -> INT
Rule 54    float -> FLOAT
Rule 55    double -> DOUBLE
Rule 56    string -> STRING
Rule 57    char -> CHAR
Rule 58    bool -> BOOL
Rule 59    null -> NULL
Rule 60    type -> TYPE
Rule 61    structure -> structure SEPARATOR type
Rule 62    structure -> type
Rule 63    type -> TYPE LBRACKET structure RBRACKET
Rule 64    vardecl -> namespace type EQUALS object
Rule 65    argtypes -> argtypes SEPARATOR object type
Rule 66    argtypes -> NAMESPACE type
Rule 67    funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
Rule 68    whileloop -> WHILE condition LBRACE program RBRACE
Rule 69    forloop -> FOR namespace IN object LBRACE program RBRACE
Rule 70    funccall -> object LPAREN elements RPAREN
Rule 71    times -> TIMES
Rule 72    divide -> DIVIDE
Rule 73    plus -> PLUS
Rule 74    minus -> MINUS
Rule 75    mod -> MOD
Rule 76    power -> POWER
Rule 77    op -> times
Rule 78    op -> divide
Rule 79    op -> plus
Rule 80    op -> minus
Rule 81    op -> mod
Rule 82    op -> power
Rule 83    expression -> expression op expression
Rule 84    expression -> expression op object
Rule 85    expression -> object op object
Rule 86    expression -> MINUS expression

Terminals, with rules where they appear

AND                  : 23
BOOL                 : 28 30 58
CHAR                 : 57
COLON                : 32
DEFINE               : 67
DIVIDE               : 72
DOUBLE               : 55
ELIF                 : 29 30
ELSE                 : 31
EQ                   : 13
EQUALS               : 64
FLOAT                : 54
FOR                  : 69
GE                   : 9
GT                   : 8
IF                   : 27 28
IN                   : 69
INT                  : 53
LBRACE               : 27 28 29 30 31 37 67 68 69
LBRACKET             : 38 63
LE                   : 11
LIKELY               : 28 30
LPAREN               : 21 39 67 70
LT                   : 10
MINUS                : 74 86
MOD                  : 75
NAMESPACE            : 52 66
NE                   : 12
NOT                  : 26
NULL                 : 59
OR                   : 24
PLUS                 : 73
POWER                : 76
RBRACE               : 27 28 29 30 31 37 67 68 69
RBRACKET             : 38 63
RPAREN               : 21 39 67 70
SEPARATOR            : 33 35 61 65
STRING               : 56
TIMES                : 71
TYPE                 : 60 63
WHILE                : 68
XOR                  : 25
error                : 

Nonterminals, with rules where they appear

argtypes             : 65 67
bool                 : 48
char                 : 47
comparator           : 20
condition            : 20 21 23 23 24 24 25 25 26 27 28 29 30 68
dict                 : 40
divide               : 78
double               : 45
elements             : 35 38 39 70
eq                   : 19
expression           : 20 22 83 83 84 86
float                : 44
forloop              : 7
funccall             : 51
funcdecl             : 5
ge                   : 15
gt                   : 14
if                   : 3 29 30 31
int                  : 43
item                 : 33 34
items                : 33 37
le                   : 17
list                 : 41
lt                   : 16
minus                : 80
mod                  : 81
namespace            : 50 64 67 69
ne                   : 18
null                 : 49
object               : 32 32 35 36 64 65 69 70 84 85 85
op                   : 83 84 85
plus                 : 79
power                : 82
program              : 1 27 28 29 30 31 67 68 69 0
statement            : 1 2
string               : 46
structure            : 61 63
times                : 77
tuple                : 42
type                 : 61 62 64 65 66 67
vardecl              : 4
whileloop            : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    program                        shift and go to state 1
    statement                      shift and go to state 2
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    statement                      shift and go to state 14
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 2

    (2) program -> statement .

    IF              reduce using rule 2 (program -> statement .)
    DEFINE          reduce using rule 2 (program -> statement .)
    WHILE           reduce using rule 2 (program -> statement .)
    FOR             reduce using rule 2 (program -> statement .)
    NAMESPACE       reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)
    RBRACE          reduce using rule 2 (program -> statement .)


state 3

    (3) statement -> if .
    (29) if -> if . ELIF condition LBRACE program RBRACE
    (30) if -> if . ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> if . ELSE LBRACE program RBRACE

    IF              reduce using rule 3 (statement -> if .)
    DEFINE          reduce using rule 3 (statement -> if .)
    WHILE           reduce using rule 3 (statement -> if .)
    FOR             reduce using rule 3 (statement -> if .)
    NAMESPACE       reduce using rule 3 (statement -> if .)
    $end            reduce using rule 3 (statement -> if .)
    RBRACE          reduce using rule 3 (statement -> if .)
    ELIF            shift and go to state 15
    ELSE            shift and go to state 16


state 4

    (4) statement -> vardecl .

    IF              reduce using rule 4 (statement -> vardecl .)
    DEFINE          reduce using rule 4 (statement -> vardecl .)
    WHILE           reduce using rule 4 (statement -> vardecl .)
    FOR             reduce using rule 4 (statement -> vardecl .)
    NAMESPACE       reduce using rule 4 (statement -> vardecl .)
    $end            reduce using rule 4 (statement -> vardecl .)
    RBRACE          reduce using rule 4 (statement -> vardecl .)


state 5

    (5) statement -> funcdecl .

    IF              reduce using rule 5 (statement -> funcdecl .)
    DEFINE          reduce using rule 5 (statement -> funcdecl .)
    WHILE           reduce using rule 5 (statement -> funcdecl .)
    FOR             reduce using rule 5 (statement -> funcdecl .)
    NAMESPACE       reduce using rule 5 (statement -> funcdecl .)
    $end            reduce using rule 5 (statement -> funcdecl .)
    RBRACE          reduce using rule 5 (statement -> funcdecl .)


state 6

    (6) statement -> whileloop .

    IF              reduce using rule 6 (statement -> whileloop .)
    DEFINE          reduce using rule 6 (statement -> whileloop .)
    WHILE           reduce using rule 6 (statement -> whileloop .)
    FOR             reduce using rule 6 (statement -> whileloop .)
    NAMESPACE       reduce using rule 6 (statement -> whileloop .)
    $end            reduce using rule 6 (statement -> whileloop .)
    RBRACE          reduce using rule 6 (statement -> whileloop .)


state 7

    (7) statement -> forloop .

    IF              reduce using rule 7 (statement -> forloop .)
    DEFINE          reduce using rule 7 (statement -> forloop .)
    WHILE           reduce using rule 7 (statement -> forloop .)
    FOR             reduce using rule 7 (statement -> forloop .)
    NAMESPACE       reduce using rule 7 (statement -> forloop .)
    $end            reduce using rule 7 (statement -> forloop .)
    RBRACE          reduce using rule 7 (statement -> forloop .)


state 8

    (27) if -> IF . condition LBRACE program RBRACE
    (28) if -> IF . condition LIKELY BOOL LBRACE program RBRACE
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 17
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 9

    (64) vardecl -> namespace . type EQUALS object
    (60) type -> . TYPE
    (63) type -> . TYPE LBRACKET structure RBRACKET

    TYPE            shift and go to state 45

    type                           shift and go to state 44

state 10

    (67) funcdecl -> DEFINE . namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 46

state 11

    (68) whileloop -> WHILE . condition LBRACE program RBRACE
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 47
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 12

    (69) forloop -> FOR . namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 48

state 13

    (52) namespace -> NAMESPACE .

    TYPE            reduce using rule 52 (namespace -> NAMESPACE .)
    LPAREN          reduce using rule 52 (namespace -> NAMESPACE .)
    TIMES           reduce using rule 52 (namespace -> NAMESPACE .)
    DIVIDE          reduce using rule 52 (namespace -> NAMESPACE .)
    PLUS            reduce using rule 52 (namespace -> NAMESPACE .)
    MINUS           reduce using rule 52 (namespace -> NAMESPACE .)
    MOD             reduce using rule 52 (namespace -> NAMESPACE .)
    POWER           reduce using rule 52 (namespace -> NAMESPACE .)
    IN              reduce using rule 52 (namespace -> NAMESPACE .)
    COLON           reduce using rule 52 (namespace -> NAMESPACE .)
    RPAREN          reduce using rule 52 (namespace -> NAMESPACE .)
    SEPARATOR       reduce using rule 52 (namespace -> NAMESPACE .)
    RBRACKET        reduce using rule 52 (namespace -> NAMESPACE .)
    LBRACE          reduce using rule 52 (namespace -> NAMESPACE .)
    LIKELY          reduce using rule 52 (namespace -> NAMESPACE .)
    AND             reduce using rule 52 (namespace -> NAMESPACE .)
    OR              reduce using rule 52 (namespace -> NAMESPACE .)
    XOR             reduce using rule 52 (namespace -> NAMESPACE .)
    GT              reduce using rule 52 (namespace -> NAMESPACE .)
    GE              reduce using rule 52 (namespace -> NAMESPACE .)
    LT              reduce using rule 52 (namespace -> NAMESPACE .)
    LE              reduce using rule 52 (namespace -> NAMESPACE .)
    NE              reduce using rule 52 (namespace -> NAMESPACE .)
    EQ              reduce using rule 52 (namespace -> NAMESPACE .)
    IF              reduce using rule 52 (namespace -> NAMESPACE .)
    DEFINE          reduce using rule 52 (namespace -> NAMESPACE .)
    WHILE           reduce using rule 52 (namespace -> NAMESPACE .)
    FOR             reduce using rule 52 (namespace -> NAMESPACE .)
    NAMESPACE       reduce using rule 52 (namespace -> NAMESPACE .)
    $end            reduce using rule 52 (namespace -> NAMESPACE .)
    RBRACE          reduce using rule 52 (namespace -> NAMESPACE .)


state 14

    (1) program -> program statement .

    IF              reduce using rule 1 (program -> program statement .)
    DEFINE          reduce using rule 1 (program -> program statement .)
    WHILE           reduce using rule 1 (program -> program statement .)
    FOR             reduce using rule 1 (program -> program statement .)
    NAMESPACE       reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)
    RBRACE          reduce using rule 1 (program -> program statement .)


state 15

    (29) if -> if ELIF . condition LBRACE program RBRACE
    (30) if -> if ELIF . condition LIKELY BOOL LBRACE program RBRACE
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 49
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 16

    (31) if -> if ELSE . LBRACE program RBRACE

    LBRACE          shift and go to state 50


state 17

    (27) if -> IF condition . LBRACE program RBRACE
    (28) if -> IF condition . LIKELY BOOL LBRACE program RBRACE
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          shift and go to state 51
    LIKELY          shift and go to state 52
    AND             shift and go to state 54
    OR              shift and go to state 55
    XOR             shift and go to state 56
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 18

    (37) dict -> LBRACE . items RBRACE
    (33) items -> . items SEPARATOR item
    (34) items -> . item
    (32) item -> . object COLON object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    items                          shift and go to state 69
    item                           shift and go to state 70
    object                         shift and go to state 71
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 19

    (58) bool -> BOOL .

    LPAREN          reduce using rule 58 (bool -> BOOL .)
    TIMES           reduce using rule 58 (bool -> BOOL .)
    DIVIDE          reduce using rule 58 (bool -> BOOL .)
    PLUS            reduce using rule 58 (bool -> BOOL .)
    MINUS           reduce using rule 58 (bool -> BOOL .)
    MOD             reduce using rule 58 (bool -> BOOL .)
    POWER           reduce using rule 58 (bool -> BOOL .)
    COLON           reduce using rule 58 (bool -> BOOL .)
    RPAREN          reduce using rule 58 (bool -> BOOL .)
    SEPARATOR       reduce using rule 58 (bool -> BOOL .)
    RBRACKET        reduce using rule 58 (bool -> BOOL .)
    LBRACE          reduce using rule 58 (bool -> BOOL .)
    LIKELY          reduce using rule 58 (bool -> BOOL .)
    AND             reduce using rule 58 (bool -> BOOL .)
    OR              reduce using rule 58 (bool -> BOOL .)
    XOR             reduce using rule 58 (bool -> BOOL .)
    GT              reduce using rule 58 (bool -> BOOL .)
    GE              reduce using rule 58 (bool -> BOOL .)
    LT              reduce using rule 58 (bool -> BOOL .)
    LE              reduce using rule 58 (bool -> BOOL .)
    NE              reduce using rule 58 (bool -> BOOL .)
    EQ              reduce using rule 58 (bool -> BOOL .)
    IF              reduce using rule 58 (bool -> BOOL .)
    DEFINE          reduce using rule 58 (bool -> BOOL .)
    WHILE           reduce using rule 58 (bool -> BOOL .)
    FOR             reduce using rule 58 (bool -> BOOL .)
    NAMESPACE       reduce using rule 58 (bool -> BOOL .)
    $end            reduce using rule 58 (bool -> BOOL .)
    RBRACE          reduce using rule 58 (bool -> BOOL .)
    TYPE            reduce using rule 58 (bool -> BOOL .)


state 20

    (22) condition -> expression .
    (83) expression -> expression . op expression
    (84) expression -> expression . op object
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

    LBRACE          reduce using rule 22 (condition -> expression .)
    LIKELY          reduce using rule 22 (condition -> expression .)
    AND             reduce using rule 22 (condition -> expression .)
    OR              reduce using rule 22 (condition -> expression .)
    XOR             reduce using rule 22 (condition -> expression .)
    GT              reduce using rule 22 (condition -> expression .)
    GE              reduce using rule 22 (condition -> expression .)
    LT              reduce using rule 22 (condition -> expression .)
    LE              reduce using rule 22 (condition -> expression .)
    NE              reduce using rule 22 (condition -> expression .)
    EQ              reduce using rule 22 (condition -> expression .)
    RPAREN          reduce using rule 22 (condition -> expression .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    MOD             shift and go to state 84
    POWER           shift and go to state 85

    op                             shift and go to state 73
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 21

    (21) condition -> LPAREN . condition RPAREN
    (39) tuple -> LPAREN . elements RPAREN
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (35) elements -> . elements SEPARATOR object
    (36) elements -> . object
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 86
    elements                       shift and go to state 87
    expression                     shift and go to state 20
    object                         shift and go to state 88
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 22

    (26) condition -> NOT . condition
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 89
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 23

    (85) expression -> object . op object
    (70) funccall -> object . LPAREN elements RPAREN
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

    LPAREN          shift and go to state 91
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    MOD             shift and go to state 84
    POWER           shift and go to state 85

    op                             shift and go to state 90
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 24

    (86) expression -> MINUS . expression
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    expression                     shift and go to state 92
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 25

    (40) object -> dict .

    LPAREN          reduce using rule 40 (object -> dict .)
    TIMES           reduce using rule 40 (object -> dict .)
    DIVIDE          reduce using rule 40 (object -> dict .)
    PLUS            reduce using rule 40 (object -> dict .)
    MINUS           reduce using rule 40 (object -> dict .)
    MOD             reduce using rule 40 (object -> dict .)
    POWER           reduce using rule 40 (object -> dict .)
    COLON           reduce using rule 40 (object -> dict .)
    RPAREN          reduce using rule 40 (object -> dict .)
    SEPARATOR       reduce using rule 40 (object -> dict .)
    RBRACKET        reduce using rule 40 (object -> dict .)
    LBRACE          reduce using rule 40 (object -> dict .)
    LIKELY          reduce using rule 40 (object -> dict .)
    AND             reduce using rule 40 (object -> dict .)
    OR              reduce using rule 40 (object -> dict .)
    XOR             reduce using rule 40 (object -> dict .)
    GT              reduce using rule 40 (object -> dict .)
    GE              reduce using rule 40 (object -> dict .)
    LT              reduce using rule 40 (object -> dict .)
    LE              reduce using rule 40 (object -> dict .)
    NE              reduce using rule 40 (object -> dict .)
    EQ              reduce using rule 40 (object -> dict .)
    IF              reduce using rule 40 (object -> dict .)
    DEFINE          reduce using rule 40 (object -> dict .)
    WHILE           reduce using rule 40 (object -> dict .)
    FOR             reduce using rule 40 (object -> dict .)
    NAMESPACE       reduce using rule 40 (object -> dict .)
    $end            reduce using rule 40 (object -> dict .)
    RBRACE          reduce using rule 40 (object -> dict .)
    TYPE            reduce using rule 40 (object -> dict .)


state 26

    (41) object -> list .

    LPAREN          reduce using rule 41 (object -> list .)
    TIMES           reduce using rule 41 (object -> list .)
    DIVIDE          reduce using rule 41 (object -> list .)
    PLUS            reduce using rule 41 (object -> list .)
    MINUS           reduce using rule 41 (object -> list .)
    MOD             reduce using rule 41 (object -> list .)
    POWER           reduce using rule 41 (object -> list .)
    COLON           reduce using rule 41 (object -> list .)
    RPAREN          reduce using rule 41 (object -> list .)
    SEPARATOR       reduce using rule 41 (object -> list .)
    RBRACKET        reduce using rule 41 (object -> list .)
    LBRACE          reduce using rule 41 (object -> list .)
    LIKELY          reduce using rule 41 (object -> list .)
    AND             reduce using rule 41 (object -> list .)
    OR              reduce using rule 41 (object -> list .)
    XOR             reduce using rule 41 (object -> list .)
    GT              reduce using rule 41 (object -> list .)
    GE              reduce using rule 41 (object -> list .)
    LT              reduce using rule 41 (object -> list .)
    LE              reduce using rule 41 (object -> list .)
    NE              reduce using rule 41 (object -> list .)
    EQ              reduce using rule 41 (object -> list .)
    IF              reduce using rule 41 (object -> list .)
    DEFINE          reduce using rule 41 (object -> list .)
    WHILE           reduce using rule 41 (object -> list .)
    FOR             reduce using rule 41 (object -> list .)
    NAMESPACE       reduce using rule 41 (object -> list .)
    $end            reduce using rule 41 (object -> list .)
    RBRACE          reduce using rule 41 (object -> list .)
    TYPE            reduce using rule 41 (object -> list .)


state 27

    (42) object -> tuple .

    LPAREN          reduce using rule 42 (object -> tuple .)
    TIMES           reduce using rule 42 (object -> tuple .)
    DIVIDE          reduce using rule 42 (object -> tuple .)
    PLUS            reduce using rule 42 (object -> tuple .)
    MINUS           reduce using rule 42 (object -> tuple .)
    MOD             reduce using rule 42 (object -> tuple .)
    POWER           reduce using rule 42 (object -> tuple .)
    COLON           reduce using rule 42 (object -> tuple .)
    RPAREN          reduce using rule 42 (object -> tuple .)
    SEPARATOR       reduce using rule 42 (object -> tuple .)
    RBRACKET        reduce using rule 42 (object -> tuple .)
    LBRACE          reduce using rule 42 (object -> tuple .)
    LIKELY          reduce using rule 42 (object -> tuple .)
    AND             reduce using rule 42 (object -> tuple .)
    OR              reduce using rule 42 (object -> tuple .)
    XOR             reduce using rule 42 (object -> tuple .)
    GT              reduce using rule 42 (object -> tuple .)
    GE              reduce using rule 42 (object -> tuple .)
    LT              reduce using rule 42 (object -> tuple .)
    LE              reduce using rule 42 (object -> tuple .)
    NE              reduce using rule 42 (object -> tuple .)
    EQ              reduce using rule 42 (object -> tuple .)
    IF              reduce using rule 42 (object -> tuple .)
    DEFINE          reduce using rule 42 (object -> tuple .)
    WHILE           reduce using rule 42 (object -> tuple .)
    FOR             reduce using rule 42 (object -> tuple .)
    NAMESPACE       reduce using rule 42 (object -> tuple .)
    $end            reduce using rule 42 (object -> tuple .)
    RBRACE          reduce using rule 42 (object -> tuple .)
    TYPE            reduce using rule 42 (object -> tuple .)


state 28

    (43) object -> int .

    LPAREN          reduce using rule 43 (object -> int .)
    TIMES           reduce using rule 43 (object -> int .)
    DIVIDE          reduce using rule 43 (object -> int .)
    PLUS            reduce using rule 43 (object -> int .)
    MINUS           reduce using rule 43 (object -> int .)
    MOD             reduce using rule 43 (object -> int .)
    POWER           reduce using rule 43 (object -> int .)
    COLON           reduce using rule 43 (object -> int .)
    RPAREN          reduce using rule 43 (object -> int .)
    SEPARATOR       reduce using rule 43 (object -> int .)
    RBRACKET        reduce using rule 43 (object -> int .)
    LBRACE          reduce using rule 43 (object -> int .)
    LIKELY          reduce using rule 43 (object -> int .)
    AND             reduce using rule 43 (object -> int .)
    OR              reduce using rule 43 (object -> int .)
    XOR             reduce using rule 43 (object -> int .)
    GT              reduce using rule 43 (object -> int .)
    GE              reduce using rule 43 (object -> int .)
    LT              reduce using rule 43 (object -> int .)
    LE              reduce using rule 43 (object -> int .)
    NE              reduce using rule 43 (object -> int .)
    EQ              reduce using rule 43 (object -> int .)
    IF              reduce using rule 43 (object -> int .)
    DEFINE          reduce using rule 43 (object -> int .)
    WHILE           reduce using rule 43 (object -> int .)
    FOR             reduce using rule 43 (object -> int .)
    NAMESPACE       reduce using rule 43 (object -> int .)
    $end            reduce using rule 43 (object -> int .)
    RBRACE          reduce using rule 43 (object -> int .)
    TYPE            reduce using rule 43 (object -> int .)


state 29

    (44) object -> float .

    LPAREN          reduce using rule 44 (object -> float .)
    TIMES           reduce using rule 44 (object -> float .)
    DIVIDE          reduce using rule 44 (object -> float .)
    PLUS            reduce using rule 44 (object -> float .)
    MINUS           reduce using rule 44 (object -> float .)
    MOD             reduce using rule 44 (object -> float .)
    POWER           reduce using rule 44 (object -> float .)
    COLON           reduce using rule 44 (object -> float .)
    RPAREN          reduce using rule 44 (object -> float .)
    SEPARATOR       reduce using rule 44 (object -> float .)
    RBRACKET        reduce using rule 44 (object -> float .)
    LBRACE          reduce using rule 44 (object -> float .)
    LIKELY          reduce using rule 44 (object -> float .)
    AND             reduce using rule 44 (object -> float .)
    OR              reduce using rule 44 (object -> float .)
    XOR             reduce using rule 44 (object -> float .)
    GT              reduce using rule 44 (object -> float .)
    GE              reduce using rule 44 (object -> float .)
    LT              reduce using rule 44 (object -> float .)
    LE              reduce using rule 44 (object -> float .)
    NE              reduce using rule 44 (object -> float .)
    EQ              reduce using rule 44 (object -> float .)
    IF              reduce using rule 44 (object -> float .)
    DEFINE          reduce using rule 44 (object -> float .)
    WHILE           reduce using rule 44 (object -> float .)
    FOR             reduce using rule 44 (object -> float .)
    NAMESPACE       reduce using rule 44 (object -> float .)
    $end            reduce using rule 44 (object -> float .)
    RBRACE          reduce using rule 44 (object -> float .)
    TYPE            reduce using rule 44 (object -> float .)


state 30

    (45) object -> double .

    LPAREN          reduce using rule 45 (object -> double .)
    TIMES           reduce using rule 45 (object -> double .)
    DIVIDE          reduce using rule 45 (object -> double .)
    PLUS            reduce using rule 45 (object -> double .)
    MINUS           reduce using rule 45 (object -> double .)
    MOD             reduce using rule 45 (object -> double .)
    POWER           reduce using rule 45 (object -> double .)
    COLON           reduce using rule 45 (object -> double .)
    RPAREN          reduce using rule 45 (object -> double .)
    SEPARATOR       reduce using rule 45 (object -> double .)
    RBRACKET        reduce using rule 45 (object -> double .)
    LBRACE          reduce using rule 45 (object -> double .)
    LIKELY          reduce using rule 45 (object -> double .)
    AND             reduce using rule 45 (object -> double .)
    OR              reduce using rule 45 (object -> double .)
    XOR             reduce using rule 45 (object -> double .)
    GT              reduce using rule 45 (object -> double .)
    GE              reduce using rule 45 (object -> double .)
    LT              reduce using rule 45 (object -> double .)
    LE              reduce using rule 45 (object -> double .)
    NE              reduce using rule 45 (object -> double .)
    EQ              reduce using rule 45 (object -> double .)
    IF              reduce using rule 45 (object -> double .)
    DEFINE          reduce using rule 45 (object -> double .)
    WHILE           reduce using rule 45 (object -> double .)
    FOR             reduce using rule 45 (object -> double .)
    NAMESPACE       reduce using rule 45 (object -> double .)
    $end            reduce using rule 45 (object -> double .)
    RBRACE          reduce using rule 45 (object -> double .)
    TYPE            reduce using rule 45 (object -> double .)


state 31

    (46) object -> string .

    LPAREN          reduce using rule 46 (object -> string .)
    TIMES           reduce using rule 46 (object -> string .)
    DIVIDE          reduce using rule 46 (object -> string .)
    PLUS            reduce using rule 46 (object -> string .)
    MINUS           reduce using rule 46 (object -> string .)
    MOD             reduce using rule 46 (object -> string .)
    POWER           reduce using rule 46 (object -> string .)
    COLON           reduce using rule 46 (object -> string .)
    RPAREN          reduce using rule 46 (object -> string .)
    SEPARATOR       reduce using rule 46 (object -> string .)
    RBRACKET        reduce using rule 46 (object -> string .)
    LBRACE          reduce using rule 46 (object -> string .)
    LIKELY          reduce using rule 46 (object -> string .)
    AND             reduce using rule 46 (object -> string .)
    OR              reduce using rule 46 (object -> string .)
    XOR             reduce using rule 46 (object -> string .)
    GT              reduce using rule 46 (object -> string .)
    GE              reduce using rule 46 (object -> string .)
    LT              reduce using rule 46 (object -> string .)
    LE              reduce using rule 46 (object -> string .)
    NE              reduce using rule 46 (object -> string .)
    EQ              reduce using rule 46 (object -> string .)
    IF              reduce using rule 46 (object -> string .)
    DEFINE          reduce using rule 46 (object -> string .)
    WHILE           reduce using rule 46 (object -> string .)
    FOR             reduce using rule 46 (object -> string .)
    NAMESPACE       reduce using rule 46 (object -> string .)
    $end            reduce using rule 46 (object -> string .)
    RBRACE          reduce using rule 46 (object -> string .)
    TYPE            reduce using rule 46 (object -> string .)


state 32

    (47) object -> char .

    LPAREN          reduce using rule 47 (object -> char .)
    TIMES           reduce using rule 47 (object -> char .)
    DIVIDE          reduce using rule 47 (object -> char .)
    PLUS            reduce using rule 47 (object -> char .)
    MINUS           reduce using rule 47 (object -> char .)
    MOD             reduce using rule 47 (object -> char .)
    POWER           reduce using rule 47 (object -> char .)
    COLON           reduce using rule 47 (object -> char .)
    RPAREN          reduce using rule 47 (object -> char .)
    SEPARATOR       reduce using rule 47 (object -> char .)
    RBRACKET        reduce using rule 47 (object -> char .)
    LBRACE          reduce using rule 47 (object -> char .)
    LIKELY          reduce using rule 47 (object -> char .)
    AND             reduce using rule 47 (object -> char .)
    OR              reduce using rule 47 (object -> char .)
    XOR             reduce using rule 47 (object -> char .)
    GT              reduce using rule 47 (object -> char .)
    GE              reduce using rule 47 (object -> char .)
    LT              reduce using rule 47 (object -> char .)
    LE              reduce using rule 47 (object -> char .)
    NE              reduce using rule 47 (object -> char .)
    EQ              reduce using rule 47 (object -> char .)
    IF              reduce using rule 47 (object -> char .)
    DEFINE          reduce using rule 47 (object -> char .)
    WHILE           reduce using rule 47 (object -> char .)
    FOR             reduce using rule 47 (object -> char .)
    NAMESPACE       reduce using rule 47 (object -> char .)
    $end            reduce using rule 47 (object -> char .)
    RBRACE          reduce using rule 47 (object -> char .)
    TYPE            reduce using rule 47 (object -> char .)


state 33

    (48) object -> bool .

    LPAREN          reduce using rule 48 (object -> bool .)
    TIMES           reduce using rule 48 (object -> bool .)
    DIVIDE          reduce using rule 48 (object -> bool .)
    PLUS            reduce using rule 48 (object -> bool .)
    MINUS           reduce using rule 48 (object -> bool .)
    MOD             reduce using rule 48 (object -> bool .)
    POWER           reduce using rule 48 (object -> bool .)
    COLON           reduce using rule 48 (object -> bool .)
    RPAREN          reduce using rule 48 (object -> bool .)
    SEPARATOR       reduce using rule 48 (object -> bool .)
    RBRACKET        reduce using rule 48 (object -> bool .)
    LBRACE          reduce using rule 48 (object -> bool .)
    LIKELY          reduce using rule 48 (object -> bool .)
    AND             reduce using rule 48 (object -> bool .)
    OR              reduce using rule 48 (object -> bool .)
    XOR             reduce using rule 48 (object -> bool .)
    GT              reduce using rule 48 (object -> bool .)
    GE              reduce using rule 48 (object -> bool .)
    LT              reduce using rule 48 (object -> bool .)
    LE              reduce using rule 48 (object -> bool .)
    NE              reduce using rule 48 (object -> bool .)
    EQ              reduce using rule 48 (object -> bool .)
    IF              reduce using rule 48 (object -> bool .)
    DEFINE          reduce using rule 48 (object -> bool .)
    WHILE           reduce using rule 48 (object -> bool .)
    FOR             reduce using rule 48 (object -> bool .)
    NAMESPACE       reduce using rule 48 (object -> bool .)
    $end            reduce using rule 48 (object -> bool .)
    RBRACE          reduce using rule 48 (object -> bool .)
    TYPE            reduce using rule 48 (object -> bool .)


state 34

    (49) object -> null .

    LPAREN          reduce using rule 49 (object -> null .)
    TIMES           reduce using rule 49 (object -> null .)
    DIVIDE          reduce using rule 49 (object -> null .)
    PLUS            reduce using rule 49 (object -> null .)
    MINUS           reduce using rule 49 (object -> null .)
    MOD             reduce using rule 49 (object -> null .)
    POWER           reduce using rule 49 (object -> null .)
    COLON           reduce using rule 49 (object -> null .)
    RPAREN          reduce using rule 49 (object -> null .)
    SEPARATOR       reduce using rule 49 (object -> null .)
    RBRACKET        reduce using rule 49 (object -> null .)
    LBRACE          reduce using rule 49 (object -> null .)
    LIKELY          reduce using rule 49 (object -> null .)
    AND             reduce using rule 49 (object -> null .)
    OR              reduce using rule 49 (object -> null .)
    XOR             reduce using rule 49 (object -> null .)
    GT              reduce using rule 49 (object -> null .)
    GE              reduce using rule 49 (object -> null .)
    LT              reduce using rule 49 (object -> null .)
    LE              reduce using rule 49 (object -> null .)
    NE              reduce using rule 49 (object -> null .)
    EQ              reduce using rule 49 (object -> null .)
    IF              reduce using rule 49 (object -> null .)
    DEFINE          reduce using rule 49 (object -> null .)
    WHILE           reduce using rule 49 (object -> null .)
    FOR             reduce using rule 49 (object -> null .)
    NAMESPACE       reduce using rule 49 (object -> null .)
    $end            reduce using rule 49 (object -> null .)
    RBRACE          reduce using rule 49 (object -> null .)
    TYPE            reduce using rule 49 (object -> null .)


state 35

    (50) object -> namespace .

    LPAREN          reduce using rule 50 (object -> namespace .)
    TIMES           reduce using rule 50 (object -> namespace .)
    DIVIDE          reduce using rule 50 (object -> namespace .)
    PLUS            reduce using rule 50 (object -> namespace .)
    MINUS           reduce using rule 50 (object -> namespace .)
    MOD             reduce using rule 50 (object -> namespace .)
    POWER           reduce using rule 50 (object -> namespace .)
    COLON           reduce using rule 50 (object -> namespace .)
    RPAREN          reduce using rule 50 (object -> namespace .)
    SEPARATOR       reduce using rule 50 (object -> namespace .)
    RBRACKET        reduce using rule 50 (object -> namespace .)
    LBRACE          reduce using rule 50 (object -> namespace .)
    LIKELY          reduce using rule 50 (object -> namespace .)
    AND             reduce using rule 50 (object -> namespace .)
    OR              reduce using rule 50 (object -> namespace .)
    XOR             reduce using rule 50 (object -> namespace .)
    GT              reduce using rule 50 (object -> namespace .)
    GE              reduce using rule 50 (object -> namespace .)
    LT              reduce using rule 50 (object -> namespace .)
    LE              reduce using rule 50 (object -> namespace .)
    NE              reduce using rule 50 (object -> namespace .)
    EQ              reduce using rule 50 (object -> namespace .)
    IF              reduce using rule 50 (object -> namespace .)
    DEFINE          reduce using rule 50 (object -> namespace .)
    WHILE           reduce using rule 50 (object -> namespace .)
    FOR             reduce using rule 50 (object -> namespace .)
    NAMESPACE       reduce using rule 50 (object -> namespace .)
    $end            reduce using rule 50 (object -> namespace .)
    RBRACE          reduce using rule 50 (object -> namespace .)
    TYPE            reduce using rule 50 (object -> namespace .)


state 36

    (51) object -> funccall .

    LPAREN          reduce using rule 51 (object -> funccall .)
    TIMES           reduce using rule 51 (object -> funccall .)
    DIVIDE          reduce using rule 51 (object -> funccall .)
    PLUS            reduce using rule 51 (object -> funccall .)
    MINUS           reduce using rule 51 (object -> funccall .)
    MOD             reduce using rule 51 (object -> funccall .)
    POWER           reduce using rule 51 (object -> funccall .)
    COLON           reduce using rule 51 (object -> funccall .)
    RPAREN          reduce using rule 51 (object -> funccall .)
    SEPARATOR       reduce using rule 51 (object -> funccall .)
    RBRACKET        reduce using rule 51 (object -> funccall .)
    LBRACE          reduce using rule 51 (object -> funccall .)
    LIKELY          reduce using rule 51 (object -> funccall .)
    AND             reduce using rule 51 (object -> funccall .)
    OR              reduce using rule 51 (object -> funccall .)
    XOR             reduce using rule 51 (object -> funccall .)
    GT              reduce using rule 51 (object -> funccall .)
    GE              reduce using rule 51 (object -> funccall .)
    LT              reduce using rule 51 (object -> funccall .)
    LE              reduce using rule 51 (object -> funccall .)
    NE              reduce using rule 51 (object -> funccall .)
    EQ              reduce using rule 51 (object -> funccall .)
    IF              reduce using rule 51 (object -> funccall .)
    DEFINE          reduce using rule 51 (object -> funccall .)
    WHILE           reduce using rule 51 (object -> funccall .)
    FOR             reduce using rule 51 (object -> funccall .)
    NAMESPACE       reduce using rule 51 (object -> funccall .)
    $end            reduce using rule 51 (object -> funccall .)
    RBRACE          reduce using rule 51 (object -> funccall .)
    TYPE            reduce using rule 51 (object -> funccall .)


state 37

    (38) list -> LBRACKET . elements RBRACKET
    (35) elements -> . elements SEPARATOR object
    (36) elements -> . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    elements                       shift and go to state 93
    object                         shift and go to state 94
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 38

    (53) int -> INT .

    LPAREN          reduce using rule 53 (int -> INT .)
    TIMES           reduce using rule 53 (int -> INT .)
    DIVIDE          reduce using rule 53 (int -> INT .)
    PLUS            reduce using rule 53 (int -> INT .)
    MINUS           reduce using rule 53 (int -> INT .)
    MOD             reduce using rule 53 (int -> INT .)
    POWER           reduce using rule 53 (int -> INT .)
    COLON           reduce using rule 53 (int -> INT .)
    RPAREN          reduce using rule 53 (int -> INT .)
    SEPARATOR       reduce using rule 53 (int -> INT .)
    RBRACKET        reduce using rule 53 (int -> INT .)
    LBRACE          reduce using rule 53 (int -> INT .)
    LIKELY          reduce using rule 53 (int -> INT .)
    AND             reduce using rule 53 (int -> INT .)
    OR              reduce using rule 53 (int -> INT .)
    XOR             reduce using rule 53 (int -> INT .)
    GT              reduce using rule 53 (int -> INT .)
    GE              reduce using rule 53 (int -> INT .)
    LT              reduce using rule 53 (int -> INT .)
    LE              reduce using rule 53 (int -> INT .)
    NE              reduce using rule 53 (int -> INT .)
    EQ              reduce using rule 53 (int -> INT .)
    IF              reduce using rule 53 (int -> INT .)
    DEFINE          reduce using rule 53 (int -> INT .)
    WHILE           reduce using rule 53 (int -> INT .)
    FOR             reduce using rule 53 (int -> INT .)
    NAMESPACE       reduce using rule 53 (int -> INT .)
    $end            reduce using rule 53 (int -> INT .)
    RBRACE          reduce using rule 53 (int -> INT .)
    TYPE            reduce using rule 53 (int -> INT .)


state 39

    (54) float -> FLOAT .

    LPAREN          reduce using rule 54 (float -> FLOAT .)
    TIMES           reduce using rule 54 (float -> FLOAT .)
    DIVIDE          reduce using rule 54 (float -> FLOAT .)
    PLUS            reduce using rule 54 (float -> FLOAT .)
    MINUS           reduce using rule 54 (float -> FLOAT .)
    MOD             reduce using rule 54 (float -> FLOAT .)
    POWER           reduce using rule 54 (float -> FLOAT .)
    COLON           reduce using rule 54 (float -> FLOAT .)
    RPAREN          reduce using rule 54 (float -> FLOAT .)
    SEPARATOR       reduce using rule 54 (float -> FLOAT .)
    RBRACKET        reduce using rule 54 (float -> FLOAT .)
    LBRACE          reduce using rule 54 (float -> FLOAT .)
    LIKELY          reduce using rule 54 (float -> FLOAT .)
    AND             reduce using rule 54 (float -> FLOAT .)
    OR              reduce using rule 54 (float -> FLOAT .)
    XOR             reduce using rule 54 (float -> FLOAT .)
    GT              reduce using rule 54 (float -> FLOAT .)
    GE              reduce using rule 54 (float -> FLOAT .)
    LT              reduce using rule 54 (float -> FLOAT .)
    LE              reduce using rule 54 (float -> FLOAT .)
    NE              reduce using rule 54 (float -> FLOAT .)
    EQ              reduce using rule 54 (float -> FLOAT .)
    IF              reduce using rule 54 (float -> FLOAT .)
    DEFINE          reduce using rule 54 (float -> FLOAT .)
    WHILE           reduce using rule 54 (float -> FLOAT .)
    FOR             reduce using rule 54 (float -> FLOAT .)
    NAMESPACE       reduce using rule 54 (float -> FLOAT .)
    $end            reduce using rule 54 (float -> FLOAT .)
    RBRACE          reduce using rule 54 (float -> FLOAT .)
    TYPE            reduce using rule 54 (float -> FLOAT .)


state 40

    (55) double -> DOUBLE .

    LPAREN          reduce using rule 55 (double -> DOUBLE .)
    TIMES           reduce using rule 55 (double -> DOUBLE .)
    DIVIDE          reduce using rule 55 (double -> DOUBLE .)
    PLUS            reduce using rule 55 (double -> DOUBLE .)
    MINUS           reduce using rule 55 (double -> DOUBLE .)
    MOD             reduce using rule 55 (double -> DOUBLE .)
    POWER           reduce using rule 55 (double -> DOUBLE .)
    COLON           reduce using rule 55 (double -> DOUBLE .)
    RPAREN          reduce using rule 55 (double -> DOUBLE .)
    SEPARATOR       reduce using rule 55 (double -> DOUBLE .)
    RBRACKET        reduce using rule 55 (double -> DOUBLE .)
    LBRACE          reduce using rule 55 (double -> DOUBLE .)
    LIKELY          reduce using rule 55 (double -> DOUBLE .)
    AND             reduce using rule 55 (double -> DOUBLE .)
    OR              reduce using rule 55 (double -> DOUBLE .)
    XOR             reduce using rule 55 (double -> DOUBLE .)
    GT              reduce using rule 55 (double -> DOUBLE .)
    GE              reduce using rule 55 (double -> DOUBLE .)
    LT              reduce using rule 55 (double -> DOUBLE .)
    LE              reduce using rule 55 (double -> DOUBLE .)
    NE              reduce using rule 55 (double -> DOUBLE .)
    EQ              reduce using rule 55 (double -> DOUBLE .)
    IF              reduce using rule 55 (double -> DOUBLE .)
    DEFINE          reduce using rule 55 (double -> DOUBLE .)
    WHILE           reduce using rule 55 (double -> DOUBLE .)
    FOR             reduce using rule 55 (double -> DOUBLE .)
    NAMESPACE       reduce using rule 55 (double -> DOUBLE .)
    $end            reduce using rule 55 (double -> DOUBLE .)
    RBRACE          reduce using rule 55 (double -> DOUBLE .)
    TYPE            reduce using rule 55 (double -> DOUBLE .)


state 41

    (56) string -> STRING .

    LPAREN          reduce using rule 56 (string -> STRING .)
    TIMES           reduce using rule 56 (string -> STRING .)
    DIVIDE          reduce using rule 56 (string -> STRING .)
    PLUS            reduce using rule 56 (string -> STRING .)
    MINUS           reduce using rule 56 (string -> STRING .)
    MOD             reduce using rule 56 (string -> STRING .)
    POWER           reduce using rule 56 (string -> STRING .)
    COLON           reduce using rule 56 (string -> STRING .)
    RPAREN          reduce using rule 56 (string -> STRING .)
    SEPARATOR       reduce using rule 56 (string -> STRING .)
    RBRACKET        reduce using rule 56 (string -> STRING .)
    LBRACE          reduce using rule 56 (string -> STRING .)
    LIKELY          reduce using rule 56 (string -> STRING .)
    AND             reduce using rule 56 (string -> STRING .)
    OR              reduce using rule 56 (string -> STRING .)
    XOR             reduce using rule 56 (string -> STRING .)
    GT              reduce using rule 56 (string -> STRING .)
    GE              reduce using rule 56 (string -> STRING .)
    LT              reduce using rule 56 (string -> STRING .)
    LE              reduce using rule 56 (string -> STRING .)
    NE              reduce using rule 56 (string -> STRING .)
    EQ              reduce using rule 56 (string -> STRING .)
    IF              reduce using rule 56 (string -> STRING .)
    DEFINE          reduce using rule 56 (string -> STRING .)
    WHILE           reduce using rule 56 (string -> STRING .)
    FOR             reduce using rule 56 (string -> STRING .)
    NAMESPACE       reduce using rule 56 (string -> STRING .)
    $end            reduce using rule 56 (string -> STRING .)
    RBRACE          reduce using rule 56 (string -> STRING .)
    TYPE            reduce using rule 56 (string -> STRING .)


state 42

    (57) char -> CHAR .

    LPAREN          reduce using rule 57 (char -> CHAR .)
    TIMES           reduce using rule 57 (char -> CHAR .)
    DIVIDE          reduce using rule 57 (char -> CHAR .)
    PLUS            reduce using rule 57 (char -> CHAR .)
    MINUS           reduce using rule 57 (char -> CHAR .)
    MOD             reduce using rule 57 (char -> CHAR .)
    POWER           reduce using rule 57 (char -> CHAR .)
    COLON           reduce using rule 57 (char -> CHAR .)
    RPAREN          reduce using rule 57 (char -> CHAR .)
    SEPARATOR       reduce using rule 57 (char -> CHAR .)
    RBRACKET        reduce using rule 57 (char -> CHAR .)
    LBRACE          reduce using rule 57 (char -> CHAR .)
    LIKELY          reduce using rule 57 (char -> CHAR .)
    AND             reduce using rule 57 (char -> CHAR .)
    OR              reduce using rule 57 (char -> CHAR .)
    XOR             reduce using rule 57 (char -> CHAR .)
    GT              reduce using rule 57 (char -> CHAR .)
    GE              reduce using rule 57 (char -> CHAR .)
    LT              reduce using rule 57 (char -> CHAR .)
    LE              reduce using rule 57 (char -> CHAR .)
    NE              reduce using rule 57 (char -> CHAR .)
    EQ              reduce using rule 57 (char -> CHAR .)
    IF              reduce using rule 57 (char -> CHAR .)
    DEFINE          reduce using rule 57 (char -> CHAR .)
    WHILE           reduce using rule 57 (char -> CHAR .)
    FOR             reduce using rule 57 (char -> CHAR .)
    NAMESPACE       reduce using rule 57 (char -> CHAR .)
    $end            reduce using rule 57 (char -> CHAR .)
    RBRACE          reduce using rule 57 (char -> CHAR .)
    TYPE            reduce using rule 57 (char -> CHAR .)


state 43

    (59) null -> NULL .

    LPAREN          reduce using rule 59 (null -> NULL .)
    TIMES           reduce using rule 59 (null -> NULL .)
    DIVIDE          reduce using rule 59 (null -> NULL .)
    PLUS            reduce using rule 59 (null -> NULL .)
    MINUS           reduce using rule 59 (null -> NULL .)
    MOD             reduce using rule 59 (null -> NULL .)
    POWER           reduce using rule 59 (null -> NULL .)
    COLON           reduce using rule 59 (null -> NULL .)
    RPAREN          reduce using rule 59 (null -> NULL .)
    SEPARATOR       reduce using rule 59 (null -> NULL .)
    RBRACKET        reduce using rule 59 (null -> NULL .)
    LBRACE          reduce using rule 59 (null -> NULL .)
    LIKELY          reduce using rule 59 (null -> NULL .)
    AND             reduce using rule 59 (null -> NULL .)
    OR              reduce using rule 59 (null -> NULL .)
    XOR             reduce using rule 59 (null -> NULL .)
    GT              reduce using rule 59 (null -> NULL .)
    GE              reduce using rule 59 (null -> NULL .)
    LT              reduce using rule 59 (null -> NULL .)
    LE              reduce using rule 59 (null -> NULL .)
    NE              reduce using rule 59 (null -> NULL .)
    EQ              reduce using rule 59 (null -> NULL .)
    IF              reduce using rule 59 (null -> NULL .)
    DEFINE          reduce using rule 59 (null -> NULL .)
    WHILE           reduce using rule 59 (null -> NULL .)
    FOR             reduce using rule 59 (null -> NULL .)
    NAMESPACE       reduce using rule 59 (null -> NULL .)
    $end            reduce using rule 59 (null -> NULL .)
    RBRACE          reduce using rule 59 (null -> NULL .)
    TYPE            reduce using rule 59 (null -> NULL .)


state 44

    (64) vardecl -> namespace type . EQUALS object

    EQUALS          shift and go to state 95


state 45

    (60) type -> TYPE .
    (63) type -> TYPE . LBRACKET structure RBRACKET

    EQUALS          reduce using rule 60 (type -> TYPE .)
    RBRACKET        reduce using rule 60 (type -> TYPE .)
    SEPARATOR       reduce using rule 60 (type -> TYPE .)
    RPAREN          reduce using rule 60 (type -> TYPE .)
    LBRACE          reduce using rule 60 (type -> TYPE .)
    LBRACKET        shift and go to state 96


state 46

    (67) funcdecl -> DEFINE namespace . LPAREN argtypes RPAREN type LBRACE program RBRACE

    LPAREN          shift and go to state 97


state 47

    (68) whileloop -> WHILE condition . LBRACE program RBRACE
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          shift and go to state 98
    AND             shift and go to state 54
    OR              shift and go to state 55
    XOR             shift and go to state 56
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 48

    (69) forloop -> FOR namespace . IN object LBRACE program RBRACE

    IN              shift and go to state 99


state 49

    (29) if -> if ELIF condition . LBRACE program RBRACE
    (30) if -> if ELIF condition . LIKELY BOOL LBRACE program RBRACE
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          shift and go to state 100
    LIKELY          shift and go to state 101
    AND             shift and go to state 54
    OR              shift and go to state 55
    XOR             shift and go to state 56
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 50

    (31) if -> if ELSE LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    if                             shift and go to state 3
    program                        shift and go to state 102
    statement                      shift and go to state 2
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 51

    (27) if -> IF condition LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    program                        shift and go to state 103
    statement                      shift and go to state 2
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 52

    (28) if -> IF condition LIKELY . BOOL LBRACE program RBRACE

    BOOL            shift and go to state 104


state 53

    (20) condition -> condition comparator . expression
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    expression                     shift and go to state 105
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 54

    (23) condition -> condition AND . condition
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 106
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 55

    (24) condition -> condition OR . condition
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 107
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 56

    (25) condition -> condition XOR . condition
    (20) condition -> . condition comparator expression
    (21) condition -> . LPAREN condition RPAREN
    (22) condition -> . expression
    (23) condition -> . condition AND condition
    (24) condition -> . condition OR condition
    (25) condition -> . condition XOR condition
    (26) condition -> . NOT condition
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LPAREN          shift and go to state 21
    NOT             shift and go to state 22
    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    condition                      shift and go to state 108
    expression                     shift and go to state 20
    object                         shift and go to state 23
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 57

    (14) comparator -> gt .

    MINUS           reduce using rule 14 (comparator -> gt .)
    LBRACE          reduce using rule 14 (comparator -> gt .)
    LBRACKET        reduce using rule 14 (comparator -> gt .)
    LPAREN          reduce using rule 14 (comparator -> gt .)
    INT             reduce using rule 14 (comparator -> gt .)
    FLOAT           reduce using rule 14 (comparator -> gt .)
    DOUBLE          reduce using rule 14 (comparator -> gt .)
    STRING          reduce using rule 14 (comparator -> gt .)
    CHAR            reduce using rule 14 (comparator -> gt .)
    BOOL            reduce using rule 14 (comparator -> gt .)
    NULL            reduce using rule 14 (comparator -> gt .)
    NAMESPACE       reduce using rule 14 (comparator -> gt .)


state 58

    (15) comparator -> ge .

    MINUS           reduce using rule 15 (comparator -> ge .)
    LBRACE          reduce using rule 15 (comparator -> ge .)
    LBRACKET        reduce using rule 15 (comparator -> ge .)
    LPAREN          reduce using rule 15 (comparator -> ge .)
    INT             reduce using rule 15 (comparator -> ge .)
    FLOAT           reduce using rule 15 (comparator -> ge .)
    DOUBLE          reduce using rule 15 (comparator -> ge .)
    STRING          reduce using rule 15 (comparator -> ge .)
    CHAR            reduce using rule 15 (comparator -> ge .)
    BOOL            reduce using rule 15 (comparator -> ge .)
    NULL            reduce using rule 15 (comparator -> ge .)
    NAMESPACE       reduce using rule 15 (comparator -> ge .)


state 59

    (16) comparator -> lt .

    MINUS           reduce using rule 16 (comparator -> lt .)
    LBRACE          reduce using rule 16 (comparator -> lt .)
    LBRACKET        reduce using rule 16 (comparator -> lt .)
    LPAREN          reduce using rule 16 (comparator -> lt .)
    INT             reduce using rule 16 (comparator -> lt .)
    FLOAT           reduce using rule 16 (comparator -> lt .)
    DOUBLE          reduce using rule 16 (comparator -> lt .)
    STRING          reduce using rule 16 (comparator -> lt .)
    CHAR            reduce using rule 16 (comparator -> lt .)
    BOOL            reduce using rule 16 (comparator -> lt .)
    NULL            reduce using rule 16 (comparator -> lt .)
    NAMESPACE       reduce using rule 16 (comparator -> lt .)


state 60

    (17) comparator -> le .

    MINUS           reduce using rule 17 (comparator -> le .)
    LBRACE          reduce using rule 17 (comparator -> le .)
    LBRACKET        reduce using rule 17 (comparator -> le .)
    LPAREN          reduce using rule 17 (comparator -> le .)
    INT             reduce using rule 17 (comparator -> le .)
    FLOAT           reduce using rule 17 (comparator -> le .)
    DOUBLE          reduce using rule 17 (comparator -> le .)
    STRING          reduce using rule 17 (comparator -> le .)
    CHAR            reduce using rule 17 (comparator -> le .)
    BOOL            reduce using rule 17 (comparator -> le .)
    NULL            reduce using rule 17 (comparator -> le .)
    NAMESPACE       reduce using rule 17 (comparator -> le .)


state 61

    (18) comparator -> ne .

    MINUS           reduce using rule 18 (comparator -> ne .)
    LBRACE          reduce using rule 18 (comparator -> ne .)
    LBRACKET        reduce using rule 18 (comparator -> ne .)
    LPAREN          reduce using rule 18 (comparator -> ne .)
    INT             reduce using rule 18 (comparator -> ne .)
    FLOAT           reduce using rule 18 (comparator -> ne .)
    DOUBLE          reduce using rule 18 (comparator -> ne .)
    STRING          reduce using rule 18 (comparator -> ne .)
    CHAR            reduce using rule 18 (comparator -> ne .)
    BOOL            reduce using rule 18 (comparator -> ne .)
    NULL            reduce using rule 18 (comparator -> ne .)
    NAMESPACE       reduce using rule 18 (comparator -> ne .)


state 62

    (19) comparator -> eq .

    MINUS           reduce using rule 19 (comparator -> eq .)
    LBRACE          reduce using rule 19 (comparator -> eq .)
    LBRACKET        reduce using rule 19 (comparator -> eq .)
    LPAREN          reduce using rule 19 (comparator -> eq .)
    INT             reduce using rule 19 (comparator -> eq .)
    FLOAT           reduce using rule 19 (comparator -> eq .)
    DOUBLE          reduce using rule 19 (comparator -> eq .)
    STRING          reduce using rule 19 (comparator -> eq .)
    CHAR            reduce using rule 19 (comparator -> eq .)
    BOOL            reduce using rule 19 (comparator -> eq .)
    NULL            reduce using rule 19 (comparator -> eq .)
    NAMESPACE       reduce using rule 19 (comparator -> eq .)


state 63

    (8) gt -> GT .

    MINUS           reduce using rule 8 (gt -> GT .)
    LBRACE          reduce using rule 8 (gt -> GT .)
    LBRACKET        reduce using rule 8 (gt -> GT .)
    LPAREN          reduce using rule 8 (gt -> GT .)
    INT             reduce using rule 8 (gt -> GT .)
    FLOAT           reduce using rule 8 (gt -> GT .)
    DOUBLE          reduce using rule 8 (gt -> GT .)
    STRING          reduce using rule 8 (gt -> GT .)
    CHAR            reduce using rule 8 (gt -> GT .)
    BOOL            reduce using rule 8 (gt -> GT .)
    NULL            reduce using rule 8 (gt -> GT .)
    NAMESPACE       reduce using rule 8 (gt -> GT .)


state 64

    (9) ge -> GE .

    MINUS           reduce using rule 9 (ge -> GE .)
    LBRACE          reduce using rule 9 (ge -> GE .)
    LBRACKET        reduce using rule 9 (ge -> GE .)
    LPAREN          reduce using rule 9 (ge -> GE .)
    INT             reduce using rule 9 (ge -> GE .)
    FLOAT           reduce using rule 9 (ge -> GE .)
    DOUBLE          reduce using rule 9 (ge -> GE .)
    STRING          reduce using rule 9 (ge -> GE .)
    CHAR            reduce using rule 9 (ge -> GE .)
    BOOL            reduce using rule 9 (ge -> GE .)
    NULL            reduce using rule 9 (ge -> GE .)
    NAMESPACE       reduce using rule 9 (ge -> GE .)


state 65

    (10) lt -> LT .

    MINUS           reduce using rule 10 (lt -> LT .)
    LBRACE          reduce using rule 10 (lt -> LT .)
    LBRACKET        reduce using rule 10 (lt -> LT .)
    LPAREN          reduce using rule 10 (lt -> LT .)
    INT             reduce using rule 10 (lt -> LT .)
    FLOAT           reduce using rule 10 (lt -> LT .)
    DOUBLE          reduce using rule 10 (lt -> LT .)
    STRING          reduce using rule 10 (lt -> LT .)
    CHAR            reduce using rule 10 (lt -> LT .)
    BOOL            reduce using rule 10 (lt -> LT .)
    NULL            reduce using rule 10 (lt -> LT .)
    NAMESPACE       reduce using rule 10 (lt -> LT .)


state 66

    (11) le -> LE .

    MINUS           reduce using rule 11 (le -> LE .)
    LBRACE          reduce using rule 11 (le -> LE .)
    LBRACKET        reduce using rule 11 (le -> LE .)
    LPAREN          reduce using rule 11 (le -> LE .)
    INT             reduce using rule 11 (le -> LE .)
    FLOAT           reduce using rule 11 (le -> LE .)
    DOUBLE          reduce using rule 11 (le -> LE .)
    STRING          reduce using rule 11 (le -> LE .)
    CHAR            reduce using rule 11 (le -> LE .)
    BOOL            reduce using rule 11 (le -> LE .)
    NULL            reduce using rule 11 (le -> LE .)
    NAMESPACE       reduce using rule 11 (le -> LE .)


state 67

    (12) ne -> NE .

    MINUS           reduce using rule 12 (ne -> NE .)
    LBRACE          reduce using rule 12 (ne -> NE .)
    LBRACKET        reduce using rule 12 (ne -> NE .)
    LPAREN          reduce using rule 12 (ne -> NE .)
    INT             reduce using rule 12 (ne -> NE .)
    FLOAT           reduce using rule 12 (ne -> NE .)
    DOUBLE          reduce using rule 12 (ne -> NE .)
    STRING          reduce using rule 12 (ne -> NE .)
    CHAR            reduce using rule 12 (ne -> NE .)
    BOOL            reduce using rule 12 (ne -> NE .)
    NULL            reduce using rule 12 (ne -> NE .)
    NAMESPACE       reduce using rule 12 (ne -> NE .)


state 68

    (13) eq -> EQ .

    MINUS           reduce using rule 13 (eq -> EQ .)
    LBRACE          reduce using rule 13 (eq -> EQ .)
    LBRACKET        reduce using rule 13 (eq -> EQ .)
    LPAREN          reduce using rule 13 (eq -> EQ .)
    INT             reduce using rule 13 (eq -> EQ .)
    FLOAT           reduce using rule 13 (eq -> EQ .)
    DOUBLE          reduce using rule 13 (eq -> EQ .)
    STRING          reduce using rule 13 (eq -> EQ .)
    CHAR            reduce using rule 13 (eq -> EQ .)
    BOOL            reduce using rule 13 (eq -> EQ .)
    NULL            reduce using rule 13 (eq -> EQ .)
    NAMESPACE       reduce using rule 13 (eq -> EQ .)


state 69

    (37) dict -> LBRACE items . RBRACE
    (33) items -> items . SEPARATOR item

    RBRACE          shift and go to state 109
    SEPARATOR       shift and go to state 110


state 70

    (34) items -> item .

    RBRACE          reduce using rule 34 (items -> item .)
    SEPARATOR       reduce using rule 34 (items -> item .)


state 71

    (32) item -> object . COLON object
    (70) funccall -> object . LPAREN elements RPAREN

    COLON           shift and go to state 111
    LPAREN          shift and go to state 91


state 72

    (39) tuple -> LPAREN . elements RPAREN
    (35) elements -> . elements SEPARATOR object
    (36) elements -> . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    elements                       shift and go to state 87
    object                         shift and go to state 94
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 73

    (83) expression -> expression op . expression
    (84) expression -> expression op . object
    (83) expression -> . expression op expression
    (84) expression -> . expression op object
    (85) expression -> . object op object
    (86) expression -> . MINUS expression
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    MINUS           shift and go to state 24
    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    expression                     shift and go to state 112
    object                         shift and go to state 113
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 74

    (77) op -> times .

    MINUS           reduce using rule 77 (op -> times .)
    LBRACE          reduce using rule 77 (op -> times .)
    LBRACKET        reduce using rule 77 (op -> times .)
    LPAREN          reduce using rule 77 (op -> times .)
    INT             reduce using rule 77 (op -> times .)
    FLOAT           reduce using rule 77 (op -> times .)
    DOUBLE          reduce using rule 77 (op -> times .)
    STRING          reduce using rule 77 (op -> times .)
    CHAR            reduce using rule 77 (op -> times .)
    BOOL            reduce using rule 77 (op -> times .)
    NULL            reduce using rule 77 (op -> times .)
    NAMESPACE       reduce using rule 77 (op -> times .)


state 75

    (78) op -> divide .

    MINUS           reduce using rule 78 (op -> divide .)
    LBRACE          reduce using rule 78 (op -> divide .)
    LBRACKET        reduce using rule 78 (op -> divide .)
    LPAREN          reduce using rule 78 (op -> divide .)
    INT             reduce using rule 78 (op -> divide .)
    FLOAT           reduce using rule 78 (op -> divide .)
    DOUBLE          reduce using rule 78 (op -> divide .)
    STRING          reduce using rule 78 (op -> divide .)
    CHAR            reduce using rule 78 (op -> divide .)
    BOOL            reduce using rule 78 (op -> divide .)
    NULL            reduce using rule 78 (op -> divide .)
    NAMESPACE       reduce using rule 78 (op -> divide .)


state 76

    (79) op -> plus .

    MINUS           reduce using rule 79 (op -> plus .)
    LBRACE          reduce using rule 79 (op -> plus .)
    LBRACKET        reduce using rule 79 (op -> plus .)
    LPAREN          reduce using rule 79 (op -> plus .)
    INT             reduce using rule 79 (op -> plus .)
    FLOAT           reduce using rule 79 (op -> plus .)
    DOUBLE          reduce using rule 79 (op -> plus .)
    STRING          reduce using rule 79 (op -> plus .)
    CHAR            reduce using rule 79 (op -> plus .)
    BOOL            reduce using rule 79 (op -> plus .)
    NULL            reduce using rule 79 (op -> plus .)
    NAMESPACE       reduce using rule 79 (op -> plus .)


state 77

    (80) op -> minus .

    MINUS           reduce using rule 80 (op -> minus .)
    LBRACE          reduce using rule 80 (op -> minus .)
    LBRACKET        reduce using rule 80 (op -> minus .)
    LPAREN          reduce using rule 80 (op -> minus .)
    INT             reduce using rule 80 (op -> minus .)
    FLOAT           reduce using rule 80 (op -> minus .)
    DOUBLE          reduce using rule 80 (op -> minus .)
    STRING          reduce using rule 80 (op -> minus .)
    CHAR            reduce using rule 80 (op -> minus .)
    BOOL            reduce using rule 80 (op -> minus .)
    NULL            reduce using rule 80 (op -> minus .)
    NAMESPACE       reduce using rule 80 (op -> minus .)


state 78

    (81) op -> mod .

    MINUS           reduce using rule 81 (op -> mod .)
    LBRACE          reduce using rule 81 (op -> mod .)
    LBRACKET        reduce using rule 81 (op -> mod .)
    LPAREN          reduce using rule 81 (op -> mod .)
    INT             reduce using rule 81 (op -> mod .)
    FLOAT           reduce using rule 81 (op -> mod .)
    DOUBLE          reduce using rule 81 (op -> mod .)
    STRING          reduce using rule 81 (op -> mod .)
    CHAR            reduce using rule 81 (op -> mod .)
    BOOL            reduce using rule 81 (op -> mod .)
    NULL            reduce using rule 81 (op -> mod .)
    NAMESPACE       reduce using rule 81 (op -> mod .)


state 79

    (82) op -> power .

    MINUS           reduce using rule 82 (op -> power .)
    LBRACE          reduce using rule 82 (op -> power .)
    LBRACKET        reduce using rule 82 (op -> power .)
    LPAREN          reduce using rule 82 (op -> power .)
    INT             reduce using rule 82 (op -> power .)
    FLOAT           reduce using rule 82 (op -> power .)
    DOUBLE          reduce using rule 82 (op -> power .)
    STRING          reduce using rule 82 (op -> power .)
    CHAR            reduce using rule 82 (op -> power .)
    BOOL            reduce using rule 82 (op -> power .)
    NULL            reduce using rule 82 (op -> power .)
    NAMESPACE       reduce using rule 82 (op -> power .)


state 80

    (71) times -> TIMES .

    MINUS           reduce using rule 71 (times -> TIMES .)
    LBRACE          reduce using rule 71 (times -> TIMES .)
    LBRACKET        reduce using rule 71 (times -> TIMES .)
    LPAREN          reduce using rule 71 (times -> TIMES .)
    INT             reduce using rule 71 (times -> TIMES .)
    FLOAT           reduce using rule 71 (times -> TIMES .)
    DOUBLE          reduce using rule 71 (times -> TIMES .)
    STRING          reduce using rule 71 (times -> TIMES .)
    CHAR            reduce using rule 71 (times -> TIMES .)
    BOOL            reduce using rule 71 (times -> TIMES .)
    NULL            reduce using rule 71 (times -> TIMES .)
    NAMESPACE       reduce using rule 71 (times -> TIMES .)


state 81

    (72) divide -> DIVIDE .

    MINUS           reduce using rule 72 (divide -> DIVIDE .)
    LBRACE          reduce using rule 72 (divide -> DIVIDE .)
    LBRACKET        reduce using rule 72 (divide -> DIVIDE .)
    LPAREN          reduce using rule 72 (divide -> DIVIDE .)
    INT             reduce using rule 72 (divide -> DIVIDE .)
    FLOAT           reduce using rule 72 (divide -> DIVIDE .)
    DOUBLE          reduce using rule 72 (divide -> DIVIDE .)
    STRING          reduce using rule 72 (divide -> DIVIDE .)
    CHAR            reduce using rule 72 (divide -> DIVIDE .)
    BOOL            reduce using rule 72 (divide -> DIVIDE .)
    NULL            reduce using rule 72 (divide -> DIVIDE .)
    NAMESPACE       reduce using rule 72 (divide -> DIVIDE .)


state 82

    (73) plus -> PLUS .

    MINUS           reduce using rule 73 (plus -> PLUS .)
    LBRACE          reduce using rule 73 (plus -> PLUS .)
    LBRACKET        reduce using rule 73 (plus -> PLUS .)
    LPAREN          reduce using rule 73 (plus -> PLUS .)
    INT             reduce using rule 73 (plus -> PLUS .)
    FLOAT           reduce using rule 73 (plus -> PLUS .)
    DOUBLE          reduce using rule 73 (plus -> PLUS .)
    STRING          reduce using rule 73 (plus -> PLUS .)
    CHAR            reduce using rule 73 (plus -> PLUS .)
    BOOL            reduce using rule 73 (plus -> PLUS .)
    NULL            reduce using rule 73 (plus -> PLUS .)
    NAMESPACE       reduce using rule 73 (plus -> PLUS .)


state 83

    (74) minus -> MINUS .

    MINUS           reduce using rule 74 (minus -> MINUS .)
    LBRACE          reduce using rule 74 (minus -> MINUS .)
    LBRACKET        reduce using rule 74 (minus -> MINUS .)
    LPAREN          reduce using rule 74 (minus -> MINUS .)
    INT             reduce using rule 74 (minus -> MINUS .)
    FLOAT           reduce using rule 74 (minus -> MINUS .)
    DOUBLE          reduce using rule 74 (minus -> MINUS .)
    STRING          reduce using rule 74 (minus -> MINUS .)
    CHAR            reduce using rule 74 (minus -> MINUS .)
    BOOL            reduce using rule 74 (minus -> MINUS .)
    NULL            reduce using rule 74 (minus -> MINUS .)
    NAMESPACE       reduce using rule 74 (minus -> MINUS .)


state 84

    (75) mod -> MOD .

    MINUS           reduce using rule 75 (mod -> MOD .)
    LBRACE          reduce using rule 75 (mod -> MOD .)
    LBRACKET        reduce using rule 75 (mod -> MOD .)
    LPAREN          reduce using rule 75 (mod -> MOD .)
    INT             reduce using rule 75 (mod -> MOD .)
    FLOAT           reduce using rule 75 (mod -> MOD .)
    DOUBLE          reduce using rule 75 (mod -> MOD .)
    STRING          reduce using rule 75 (mod -> MOD .)
    CHAR            reduce using rule 75 (mod -> MOD .)
    BOOL            reduce using rule 75 (mod -> MOD .)
    NULL            reduce using rule 75 (mod -> MOD .)
    NAMESPACE       reduce using rule 75 (mod -> MOD .)


state 85

    (76) power -> POWER .

    MINUS           reduce using rule 76 (power -> POWER .)
    LBRACE          reduce using rule 76 (power -> POWER .)
    LBRACKET        reduce using rule 76 (power -> POWER .)
    LPAREN          reduce using rule 76 (power -> POWER .)
    INT             reduce using rule 76 (power -> POWER .)
    FLOAT           reduce using rule 76 (power -> POWER .)
    DOUBLE          reduce using rule 76 (power -> POWER .)
    STRING          reduce using rule 76 (power -> POWER .)
    CHAR            reduce using rule 76 (power -> POWER .)
    BOOL            reduce using rule 76 (power -> POWER .)
    NULL            reduce using rule 76 (power -> POWER .)
    NAMESPACE       reduce using rule 76 (power -> POWER .)


state 86

    (21) condition -> LPAREN condition . RPAREN
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    RPAREN          shift and go to state 114
    AND             shift and go to state 54
    OR              shift and go to state 55
    XOR             shift and go to state 56
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 87

    (39) tuple -> LPAREN elements . RPAREN
    (35) elements -> elements . SEPARATOR object

    RPAREN          shift and go to state 115
    SEPARATOR       shift and go to state 116


state 88

    (36) elements -> object .
    (85) expression -> object . op object
    (70) funccall -> object . LPAREN elements RPAREN
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

    RPAREN          reduce using rule 36 (elements -> object .)
    SEPARATOR       reduce using rule 36 (elements -> object .)
    LPAREN          shift and go to state 91
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    MOD             shift and go to state 84
    POWER           shift and go to state 85

    op                             shift and go to state 90
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 89

    (26) condition -> NOT condition .
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          reduce using rule 26 (condition -> NOT condition .)
    LIKELY          reduce using rule 26 (condition -> NOT condition .)
    AND             reduce using rule 26 (condition -> NOT condition .)
    OR              reduce using rule 26 (condition -> NOT condition .)
    XOR             reduce using rule 26 (condition -> NOT condition .)
    RPAREN          reduce using rule 26 (condition -> NOT condition .)
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

  ! GT              [ reduce using rule 26 (condition -> NOT condition .) ]
  ! GE              [ reduce using rule 26 (condition -> NOT condition .) ]
  ! LT              [ reduce using rule 26 (condition -> NOT condition .) ]
  ! LE              [ reduce using rule 26 (condition -> NOT condition .) ]
  ! NE              [ reduce using rule 26 (condition -> NOT condition .) ]
  ! EQ              [ reduce using rule 26 (condition -> NOT condition .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! XOR             [ shift and go to state 56 ]

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 90

    (85) expression -> object op . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    object                         shift and go to state 117
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 91

    (70) funccall -> object LPAREN . elements RPAREN
    (35) elements -> . elements SEPARATOR object
    (36) elements -> . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    object                         shift and go to state 94
    elements                       shift and go to state 118
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 92

    (86) expression -> MINUS expression .
    (83) expression -> expression . op expression
    (84) expression -> expression . op object
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

    TIMES           reduce using rule 86 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 86 (expression -> MINUS expression .)
    PLUS            reduce using rule 86 (expression -> MINUS expression .)
    MINUS           reduce using rule 86 (expression -> MINUS expression .)
    MOD             reduce using rule 86 (expression -> MINUS expression .)
    POWER           reduce using rule 86 (expression -> MINUS expression .)
    LBRACE          reduce using rule 86 (expression -> MINUS expression .)
    LIKELY          reduce using rule 86 (expression -> MINUS expression .)
    AND             reduce using rule 86 (expression -> MINUS expression .)
    OR              reduce using rule 86 (expression -> MINUS expression .)
    XOR             reduce using rule 86 (expression -> MINUS expression .)
    GT              reduce using rule 86 (expression -> MINUS expression .)
    GE              reduce using rule 86 (expression -> MINUS expression .)
    LT              reduce using rule 86 (expression -> MINUS expression .)
    LE              reduce using rule 86 (expression -> MINUS expression .)
    NE              reduce using rule 86 (expression -> MINUS expression .)
    EQ              reduce using rule 86 (expression -> MINUS expression .)
    RPAREN          reduce using rule 86 (expression -> MINUS expression .)

  ! TIMES           [ shift and go to state 80 ]
  ! DIVIDE          [ shift and go to state 81 ]
  ! PLUS            [ shift and go to state 82 ]
  ! MINUS           [ shift and go to state 83 ]
  ! MOD             [ shift and go to state 84 ]
  ! POWER           [ shift and go to state 85 ]

    op                             shift and go to state 73
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 93

    (38) list -> LBRACKET elements . RBRACKET
    (35) elements -> elements . SEPARATOR object

    RBRACKET        shift and go to state 119
    SEPARATOR       shift and go to state 116


state 94

    (36) elements -> object .
    (70) funccall -> object . LPAREN elements RPAREN

    RBRACKET        reduce using rule 36 (elements -> object .)
    SEPARATOR       reduce using rule 36 (elements -> object .)
    RPAREN          reduce using rule 36 (elements -> object .)
    LPAREN          shift and go to state 91


state 95

    (64) vardecl -> namespace type EQUALS . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 35
    object                         shift and go to state 120
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    funccall                       shift and go to state 36

state 96

    (63) type -> TYPE LBRACKET . structure RBRACKET
    (61) structure -> . structure SEPARATOR type
    (62) structure -> . type
    (60) type -> . TYPE
    (63) type -> . TYPE LBRACKET structure RBRACKET

    TYPE            shift and go to state 45

    structure                      shift and go to state 121
    type                           shift and go to state 122

state 97

    (67) funcdecl -> DEFINE namespace LPAREN . argtypes RPAREN type LBRACE program RBRACE
    (65) argtypes -> . argtypes SEPARATOR object type
    (66) argtypes -> . NAMESPACE type

    NAMESPACE       shift and go to state 124

    argtypes                       shift and go to state 123

state 98

    (68) whileloop -> WHILE condition LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    program                        shift and go to state 125
    statement                      shift and go to state 2
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 99

    (69) forloop -> FOR namespace IN . object LBRACE program RBRACE
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 35
    object                         shift and go to state 126
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    funccall                       shift and go to state 36

state 100

    (29) if -> if ELIF condition LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    if                             shift and go to state 3
    program                        shift and go to state 127
    statement                      shift and go to state 2
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 101

    (30) if -> if ELIF condition LIKELY . BOOL LBRACE program RBRACE

    BOOL            shift and go to state 128


state 102

    (31) if -> if ELSE LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 129
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    if                             shift and go to state 3
    statement                      shift and go to state 14
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 103

    (27) if -> IF condition LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 130
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    statement                      shift and go to state 14
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 104

    (28) if -> IF condition LIKELY BOOL . LBRACE program RBRACE

    LBRACE          shift and go to state 131


state 105

    (20) condition -> condition comparator expression .
    (83) expression -> expression . op expression
    (84) expression -> expression . op object
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

    LBRACE          reduce using rule 20 (condition -> condition comparator expression .)
    LIKELY          reduce using rule 20 (condition -> condition comparator expression .)
    AND             reduce using rule 20 (condition -> condition comparator expression .)
    OR              reduce using rule 20 (condition -> condition comparator expression .)
    XOR             reduce using rule 20 (condition -> condition comparator expression .)
    GT              reduce using rule 20 (condition -> condition comparator expression .)
    GE              reduce using rule 20 (condition -> condition comparator expression .)
    LT              reduce using rule 20 (condition -> condition comparator expression .)
    LE              reduce using rule 20 (condition -> condition comparator expression .)
    NE              reduce using rule 20 (condition -> condition comparator expression .)
    EQ              reduce using rule 20 (condition -> condition comparator expression .)
    RPAREN          reduce using rule 20 (condition -> condition comparator expression .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    MOD             shift and go to state 84
    POWER           shift and go to state 85

    op                             shift and go to state 73
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 106

    (23) condition -> condition AND condition .
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          reduce using rule 23 (condition -> condition AND condition .)
    LIKELY          reduce using rule 23 (condition -> condition AND condition .)
    AND             reduce using rule 23 (condition -> condition AND condition .)
    OR              reduce using rule 23 (condition -> condition AND condition .)
    XOR             reduce using rule 23 (condition -> condition AND condition .)
    RPAREN          reduce using rule 23 (condition -> condition AND condition .)
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

  ! GT              [ reduce using rule 23 (condition -> condition AND condition .) ]
  ! GE              [ reduce using rule 23 (condition -> condition AND condition .) ]
  ! LT              [ reduce using rule 23 (condition -> condition AND condition .) ]
  ! LE              [ reduce using rule 23 (condition -> condition AND condition .) ]
  ! NE              [ reduce using rule 23 (condition -> condition AND condition .) ]
  ! EQ              [ reduce using rule 23 (condition -> condition AND condition .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! XOR             [ shift and go to state 56 ]

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 107

    (24) condition -> condition OR condition .
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          reduce using rule 24 (condition -> condition OR condition .)
    LIKELY          reduce using rule 24 (condition -> condition OR condition .)
    AND             reduce using rule 24 (condition -> condition OR condition .)
    OR              reduce using rule 24 (condition -> condition OR condition .)
    XOR             reduce using rule 24 (condition -> condition OR condition .)
    RPAREN          reduce using rule 24 (condition -> condition OR condition .)
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

  ! GT              [ reduce using rule 24 (condition -> condition OR condition .) ]
  ! GE              [ reduce using rule 24 (condition -> condition OR condition .) ]
  ! LT              [ reduce using rule 24 (condition -> condition OR condition .) ]
  ! LE              [ reduce using rule 24 (condition -> condition OR condition .) ]
  ! NE              [ reduce using rule 24 (condition -> condition OR condition .) ]
  ! EQ              [ reduce using rule 24 (condition -> condition OR condition .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! XOR             [ shift and go to state 56 ]

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 108

    (25) condition -> condition XOR condition .
    (20) condition -> condition . comparator expression
    (23) condition -> condition . AND condition
    (24) condition -> condition . OR condition
    (25) condition -> condition . XOR condition
    (14) comparator -> . gt
    (15) comparator -> . ge
    (16) comparator -> . lt
    (17) comparator -> . le
    (18) comparator -> . ne
    (19) comparator -> . eq
    (8) gt -> . GT
    (9) ge -> . GE
    (10) lt -> . LT
    (11) le -> . LE
    (12) ne -> . NE
    (13) eq -> . EQ

    LBRACE          reduce using rule 25 (condition -> condition XOR condition .)
    LIKELY          reduce using rule 25 (condition -> condition XOR condition .)
    AND             reduce using rule 25 (condition -> condition XOR condition .)
    OR              reduce using rule 25 (condition -> condition XOR condition .)
    XOR             reduce using rule 25 (condition -> condition XOR condition .)
    RPAREN          reduce using rule 25 (condition -> condition XOR condition .)
    GT              shift and go to state 63
    GE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    NE              shift and go to state 67
    EQ              shift and go to state 68

  ! GT              [ reduce using rule 25 (condition -> condition XOR condition .) ]
  ! GE              [ reduce using rule 25 (condition -> condition XOR condition .) ]
  ! LT              [ reduce using rule 25 (condition -> condition XOR condition .) ]
  ! LE              [ reduce using rule 25 (condition -> condition XOR condition .) ]
  ! NE              [ reduce using rule 25 (condition -> condition XOR condition .) ]
  ! EQ              [ reduce using rule 25 (condition -> condition XOR condition .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! XOR             [ shift and go to state 56 ]

    comparator                     shift and go to state 53
    gt                             shift and go to state 57
    ge                             shift and go to state 58
    lt                             shift and go to state 59
    le                             shift and go to state 60
    ne                             shift and go to state 61
    eq                             shift and go to state 62

state 109

    (37) dict -> LBRACE items RBRACE .

    LPAREN          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    TIMES           reduce using rule 37 (dict -> LBRACE items RBRACE .)
    DIVIDE          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    PLUS            reduce using rule 37 (dict -> LBRACE items RBRACE .)
    MINUS           reduce using rule 37 (dict -> LBRACE items RBRACE .)
    MOD             reduce using rule 37 (dict -> LBRACE items RBRACE .)
    POWER           reduce using rule 37 (dict -> LBRACE items RBRACE .)
    COLON           reduce using rule 37 (dict -> LBRACE items RBRACE .)
    RPAREN          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    SEPARATOR       reduce using rule 37 (dict -> LBRACE items RBRACE .)
    RBRACKET        reduce using rule 37 (dict -> LBRACE items RBRACE .)
    LBRACE          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    LIKELY          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    AND             reduce using rule 37 (dict -> LBRACE items RBRACE .)
    OR              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    XOR             reduce using rule 37 (dict -> LBRACE items RBRACE .)
    GT              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    GE              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    LT              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    LE              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    NE              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    EQ              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    IF              reduce using rule 37 (dict -> LBRACE items RBRACE .)
    DEFINE          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    WHILE           reduce using rule 37 (dict -> LBRACE items RBRACE .)
    FOR             reduce using rule 37 (dict -> LBRACE items RBRACE .)
    NAMESPACE       reduce using rule 37 (dict -> LBRACE items RBRACE .)
    $end            reduce using rule 37 (dict -> LBRACE items RBRACE .)
    RBRACE          reduce using rule 37 (dict -> LBRACE items RBRACE .)
    TYPE            reduce using rule 37 (dict -> LBRACE items RBRACE .)


state 110

    (33) items -> items SEPARATOR . item
    (32) item -> . object COLON object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    item                           shift and go to state 132
    object                         shift and go to state 71
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 111

    (32) item -> object COLON . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    object                         shift and go to state 133
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 112

    (83) expression -> expression op expression .
    (83) expression -> expression . op expression
    (84) expression -> expression . op object
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    LBRACE          reduce using rule 83 (expression -> expression op expression .)
    LIKELY          reduce using rule 83 (expression -> expression op expression .)
    AND             reduce using rule 83 (expression -> expression op expression .)
    OR              reduce using rule 83 (expression -> expression op expression .)
    XOR             reduce using rule 83 (expression -> expression op expression .)
    GT              reduce using rule 83 (expression -> expression op expression .)
    GE              reduce using rule 83 (expression -> expression op expression .)
    LT              reduce using rule 83 (expression -> expression op expression .)
    LE              reduce using rule 83 (expression -> expression op expression .)
    NE              reduce using rule 83 (expression -> expression op expression .)
    EQ              reduce using rule 83 (expression -> expression op expression .)
    RPAREN          reduce using rule 83 (expression -> expression op expression .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    MOD             shift and go to state 84
    POWER           shift and go to state 85

  ! TIMES           [ reduce using rule 83 (expression -> expression op expression .) ]
  ! DIVIDE          [ reduce using rule 83 (expression -> expression op expression .) ]
  ! PLUS            [ reduce using rule 83 (expression -> expression op expression .) ]
  ! MINUS           [ reduce using rule 83 (expression -> expression op expression .) ]
  ! MOD             [ reduce using rule 83 (expression -> expression op expression .) ]
  ! POWER           [ reduce using rule 83 (expression -> expression op expression .) ]

    op                             shift and go to state 73
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 113

    (84) expression -> expression op object .
    (85) expression -> object . op object
    (70) funccall -> object . LPAREN elements RPAREN
    (77) op -> . times
    (78) op -> . divide
    (79) op -> . plus
    (80) op -> . minus
    (81) op -> . mod
    (82) op -> . power
    (71) times -> . TIMES
    (72) divide -> . DIVIDE
    (73) plus -> . PLUS
    (74) minus -> . MINUS
    (75) mod -> . MOD
    (76) power -> . POWER

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    LBRACE          reduce using rule 84 (expression -> expression op object .)
    LIKELY          reduce using rule 84 (expression -> expression op object .)
    AND             reduce using rule 84 (expression -> expression op object .)
    OR              reduce using rule 84 (expression -> expression op object .)
    XOR             reduce using rule 84 (expression -> expression op object .)
    GT              reduce using rule 84 (expression -> expression op object .)
    GE              reduce using rule 84 (expression -> expression op object .)
    LT              reduce using rule 84 (expression -> expression op object .)
    LE              reduce using rule 84 (expression -> expression op object .)
    NE              reduce using rule 84 (expression -> expression op object .)
    EQ              reduce using rule 84 (expression -> expression op object .)
    RPAREN          reduce using rule 84 (expression -> expression op object .)
    LPAREN          shift and go to state 91
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    MOD             shift and go to state 84
    POWER           shift and go to state 85

  ! TIMES           [ reduce using rule 84 (expression -> expression op object .) ]
  ! DIVIDE          [ reduce using rule 84 (expression -> expression op object .) ]
  ! PLUS            [ reduce using rule 84 (expression -> expression op object .) ]
  ! MINUS           [ reduce using rule 84 (expression -> expression op object .) ]
  ! MOD             [ reduce using rule 84 (expression -> expression op object .) ]
  ! POWER           [ reduce using rule 84 (expression -> expression op object .) ]

    op                             shift and go to state 90
    times                          shift and go to state 74
    divide                         shift and go to state 75
    plus                           shift and go to state 76
    minus                          shift and go to state 77
    mod                            shift and go to state 78
    power                          shift and go to state 79

state 114

    (21) condition -> LPAREN condition RPAREN .

    LBRACE          reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    LIKELY          reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    AND             reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    OR              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    XOR             reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    GT              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    GE              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    LT              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    LE              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    NE              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    EQ              reduce using rule 21 (condition -> LPAREN condition RPAREN .)
    RPAREN          reduce using rule 21 (condition -> LPAREN condition RPAREN .)


state 115

    (39) tuple -> LPAREN elements RPAREN .

    LPAREN          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    TIMES           reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    DIVIDE          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    PLUS            reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    MINUS           reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    MOD             reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    POWER           reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    COLON           reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    RPAREN          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    SEPARATOR       reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    RBRACKET        reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    LBRACE          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    LIKELY          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    AND             reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    OR              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    XOR             reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    GT              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    GE              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    LT              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    LE              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    NE              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    EQ              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    IF              reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    DEFINE          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    WHILE           reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    FOR             reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    NAMESPACE       reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    $end            reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    RBRACE          reduce using rule 39 (tuple -> LPAREN elements RPAREN .)
    TYPE            reduce using rule 39 (tuple -> LPAREN elements RPAREN .)


state 116

    (35) elements -> elements SEPARATOR . object
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    object                         shift and go to state 134
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 117

    (85) expression -> object op object .
    (70) funccall -> object . LPAREN elements RPAREN

    TIMES           reduce using rule 85 (expression -> object op object .)
    DIVIDE          reduce using rule 85 (expression -> object op object .)
    PLUS            reduce using rule 85 (expression -> object op object .)
    MINUS           reduce using rule 85 (expression -> object op object .)
    MOD             reduce using rule 85 (expression -> object op object .)
    POWER           reduce using rule 85 (expression -> object op object .)
    LBRACE          reduce using rule 85 (expression -> object op object .)
    LIKELY          reduce using rule 85 (expression -> object op object .)
    AND             reduce using rule 85 (expression -> object op object .)
    OR              reduce using rule 85 (expression -> object op object .)
    XOR             reduce using rule 85 (expression -> object op object .)
    GT              reduce using rule 85 (expression -> object op object .)
    GE              reduce using rule 85 (expression -> object op object .)
    LT              reduce using rule 85 (expression -> object op object .)
    LE              reduce using rule 85 (expression -> object op object .)
    NE              reduce using rule 85 (expression -> object op object .)
    EQ              reduce using rule 85 (expression -> object op object .)
    RPAREN          reduce using rule 85 (expression -> object op object .)
    LPAREN          shift and go to state 91


state 118

    (70) funccall -> object LPAREN elements . RPAREN
    (35) elements -> elements . SEPARATOR object

    RPAREN          shift and go to state 135
    SEPARATOR       shift and go to state 116


state 119

    (38) list -> LBRACKET elements RBRACKET .

    LPAREN          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    TIMES           reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    DIVIDE          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    PLUS            reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    MINUS           reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    MOD             reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    POWER           reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    COLON           reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    RPAREN          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    SEPARATOR       reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    RBRACKET        reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    LBRACE          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    LIKELY          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    AND             reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    OR              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    XOR             reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    GT              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    GE              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    LT              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    LE              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    NE              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    EQ              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    IF              reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    DEFINE          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    WHILE           reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    FOR             reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    NAMESPACE       reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    $end            reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    RBRACE          reduce using rule 38 (list -> LBRACKET elements RBRACKET .)
    TYPE            reduce using rule 38 (list -> LBRACKET elements RBRACKET .)


state 120

    (64) vardecl -> namespace type EQUALS object .
    (70) funccall -> object . LPAREN elements RPAREN

    IF              reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    DEFINE          reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    WHILE           reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    FOR             reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    NAMESPACE       reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    $end            reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    RBRACE          reduce using rule 64 (vardecl -> namespace type EQUALS object .)
    LPAREN          shift and go to state 91


state 121

    (63) type -> TYPE LBRACKET structure . RBRACKET
    (61) structure -> structure . SEPARATOR type

    RBRACKET        shift and go to state 136
    SEPARATOR       shift and go to state 137


state 122

    (62) structure -> type .

    RBRACKET        reduce using rule 62 (structure -> type .)
    SEPARATOR       reduce using rule 62 (structure -> type .)


state 123

    (67) funcdecl -> DEFINE namespace LPAREN argtypes . RPAREN type LBRACE program RBRACE
    (65) argtypes -> argtypes . SEPARATOR object type

    RPAREN          shift and go to state 138
    SEPARATOR       shift and go to state 139


state 124

    (66) argtypes -> NAMESPACE . type
    (60) type -> . TYPE
    (63) type -> . TYPE LBRACKET structure RBRACKET

    TYPE            shift and go to state 45

    type                           shift and go to state 140

state 125

    (68) whileloop -> WHILE condition LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 141
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    statement                      shift and go to state 14
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 126

    (69) forloop -> FOR namespace IN object . LBRACE program RBRACE
    (70) funccall -> object . LPAREN elements RPAREN

    LBRACE          shift and go to state 142
    LPAREN          shift and go to state 91


state 127

    (29) if -> if ELIF condition LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 143
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    if                             shift and go to state 3
    statement                      shift and go to state 14
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 128

    (30) if -> if ELIF condition LIKELY BOOL . LBRACE program RBRACE

    LBRACE          shift and go to state 144


state 129

    (31) if -> if ELSE LBRACE program RBRACE .

    ELIF            reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    ELSE            reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    IF              reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    DEFINE          reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    WHILE           reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    FOR             reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    $end            reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)
    RBRACE          reduce using rule 31 (if -> if ELSE LBRACE program RBRACE .)


state 130

    (27) if -> IF condition LBRACE program RBRACE .

    ELIF            reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    ELSE            reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    IF              reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    DEFINE          reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    WHILE           reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    FOR             reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    $end            reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)
    RBRACE          reduce using rule 27 (if -> IF condition LBRACE program RBRACE .)


state 131

    (28) if -> IF condition LIKELY BOOL LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    program                        shift and go to state 145
    statement                      shift and go to state 2
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 132

    (33) items -> items SEPARATOR item .

    RBRACE          reduce using rule 33 (items -> items SEPARATOR item .)
    SEPARATOR       reduce using rule 33 (items -> items SEPARATOR item .)


state 133

    (32) item -> object COLON object .
    (70) funccall -> object . LPAREN elements RPAREN

    RBRACE          reduce using rule 32 (item -> object COLON object .)
    SEPARATOR       reduce using rule 32 (item -> object COLON object .)
    LPAREN          shift and go to state 91


state 134

    (35) elements -> elements SEPARATOR object .
    (70) funccall -> object . LPAREN elements RPAREN

    RPAREN          reduce using rule 35 (elements -> elements SEPARATOR object .)
    SEPARATOR       reduce using rule 35 (elements -> elements SEPARATOR object .)
    RBRACKET        reduce using rule 35 (elements -> elements SEPARATOR object .)
    LPAREN          shift and go to state 91


state 135

    (70) funccall -> object LPAREN elements RPAREN .

    LPAREN          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    TIMES           reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    DIVIDE          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    PLUS            reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    MINUS           reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    MOD             reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    POWER           reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    COLON           reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    RPAREN          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    SEPARATOR       reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    RBRACKET        reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    LBRACE          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    LIKELY          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    AND             reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    OR              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    XOR             reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    GT              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    GE              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    LT              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    LE              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    NE              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    EQ              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    IF              reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    DEFINE          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    WHILE           reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    FOR             reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    NAMESPACE       reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    $end            reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    RBRACE          reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)
    TYPE            reduce using rule 70 (funccall -> object LPAREN elements RPAREN .)


state 136

    (63) type -> TYPE LBRACKET structure RBRACKET .

    EQUALS          reduce using rule 63 (type -> TYPE LBRACKET structure RBRACKET .)
    RBRACKET        reduce using rule 63 (type -> TYPE LBRACKET structure RBRACKET .)
    SEPARATOR       reduce using rule 63 (type -> TYPE LBRACKET structure RBRACKET .)
    RPAREN          reduce using rule 63 (type -> TYPE LBRACKET structure RBRACKET .)
    LBRACE          reduce using rule 63 (type -> TYPE LBRACKET structure RBRACKET .)


state 137

    (61) structure -> structure SEPARATOR . type
    (60) type -> . TYPE
    (63) type -> . TYPE LBRACKET structure RBRACKET

    TYPE            shift and go to state 45

    type                           shift and go to state 146

state 138

    (67) funcdecl -> DEFINE namespace LPAREN argtypes RPAREN . type LBRACE program RBRACE
    (60) type -> . TYPE
    (63) type -> . TYPE LBRACKET structure RBRACKET

    TYPE            shift and go to state 45

    type                           shift and go to state 147

state 139

    (65) argtypes -> argtypes SEPARATOR . object type
    (40) object -> . dict
    (41) object -> . list
    (42) object -> . tuple
    (43) object -> . int
    (44) object -> . float
    (45) object -> . double
    (46) object -> . string
    (47) object -> . char
    (48) object -> . bool
    (49) object -> . null
    (50) object -> . namespace
    (51) object -> . funccall
    (37) dict -> . LBRACE items RBRACE
    (38) list -> . LBRACKET elements RBRACKET
    (39) tuple -> . LPAREN elements RPAREN
    (53) int -> . INT
    (54) float -> . FLOAT
    (55) double -> . DOUBLE
    (56) string -> . STRING
    (57) char -> . CHAR
    (58) bool -> . BOOL
    (59) null -> . NULL
    (52) namespace -> . NAMESPACE
    (70) funccall -> . object LPAREN elements RPAREN

    LBRACE          shift and go to state 18
    LBRACKET        shift and go to state 37
    LPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 41
    CHAR            shift and go to state 42
    BOOL            shift and go to state 19
    NULL            shift and go to state 43
    NAMESPACE       shift and go to state 13

    object                         shift and go to state 148
    dict                           shift and go to state 25
    list                           shift and go to state 26
    tuple                          shift and go to state 27
    int                            shift and go to state 28
    float                          shift and go to state 29
    double                         shift and go to state 30
    string                         shift and go to state 31
    char                           shift and go to state 32
    bool                           shift and go to state 33
    null                           shift and go to state 34
    namespace                      shift and go to state 35
    funccall                       shift and go to state 36

state 140

    (66) argtypes -> NAMESPACE type .

    RPAREN          reduce using rule 66 (argtypes -> NAMESPACE type .)
    SEPARATOR       reduce using rule 66 (argtypes -> NAMESPACE type .)


state 141

    (68) whileloop -> WHILE condition LBRACE program RBRACE .

    IF              reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)
    DEFINE          reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)
    WHILE           reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)
    FOR             reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)
    $end            reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)
    RBRACE          reduce using rule 68 (whileloop -> WHILE condition LBRACE program RBRACE .)


state 142

    (69) forloop -> FOR namespace IN object LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 9
    program                        shift and go to state 149
    statement                      shift and go to state 2
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7

state 143

    (29) if -> if ELIF condition LBRACE program RBRACE .

    ELIF            reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    ELSE            reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    IF              reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    DEFINE          reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    WHILE           reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    FOR             reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    $end            reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)
    RBRACE          reduce using rule 29 (if -> if ELIF condition LBRACE program RBRACE .)


state 144

    (30) if -> if ELIF condition LIKELY BOOL LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    if                             shift and go to state 3
    program                        shift and go to state 150
    statement                      shift and go to state 2
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 145

    (28) if -> IF condition LIKELY BOOL LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 151
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    statement                      shift and go to state 14
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 146

    (61) structure -> structure SEPARATOR type .

    RBRACKET        reduce using rule 61 (structure -> structure SEPARATOR type .)
    SEPARATOR       reduce using rule 61 (structure -> structure SEPARATOR type .)


state 147

    (67) funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 152


state 148

    (65) argtypes -> argtypes SEPARATOR object . type
    (70) funccall -> object . LPAREN elements RPAREN
    (60) type -> . TYPE
    (63) type -> . TYPE LBRACKET structure RBRACKET

    LPAREN          shift and go to state 91
    TYPE            shift and go to state 45

    type                           shift and go to state 153

state 149

    (69) forloop -> FOR namespace IN object LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 154
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 9
    statement                      shift and go to state 14
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7

state 150

    (30) if -> if ELIF condition LIKELY BOOL LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 155
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    if                             shift and go to state 3
    statement                      shift and go to state 14
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7
    namespace                      shift and go to state 9

state 151

    (28) if -> IF condition LIKELY BOOL LBRACE program RBRACE .

    ELIF            reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    ELSE            reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    IF              reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    DEFINE          reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    WHILE           reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    FOR             reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    $end            reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)
    RBRACE          reduce using rule 28 (if -> IF condition LIKELY BOOL LBRACE program RBRACE .)


state 152

    (67) funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE . program RBRACE
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 9
    program                        shift and go to state 156
    statement                      shift and go to state 2
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7

state 153

    (65) argtypes -> argtypes SEPARATOR object type .

    RPAREN          reduce using rule 65 (argtypes -> argtypes SEPARATOR object type .)
    SEPARATOR       reduce using rule 65 (argtypes -> argtypes SEPARATOR object type .)


state 154

    (69) forloop -> FOR namespace IN object LBRACE program RBRACE .

    IF              reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)
    DEFINE          reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)
    WHILE           reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)
    FOR             reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)
    $end            reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)
    RBRACE          reduce using rule 69 (forloop -> FOR namespace IN object LBRACE program RBRACE .)


state 155

    (30) if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .

    ELIF            reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    ELSE            reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    IF              reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    DEFINE          reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    WHILE           reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    FOR             reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    $end            reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)
    RBRACE          reduce using rule 30 (if -> if ELIF condition LIKELY BOOL LBRACE program RBRACE .)


state 156

    (67) funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program . RBRACE
    (1) program -> program . statement
    (3) statement -> . if
    (4) statement -> . vardecl
    (5) statement -> . funcdecl
    (6) statement -> . whileloop
    (7) statement -> . forloop
    (27) if -> . IF condition LBRACE program RBRACE
    (28) if -> . IF condition LIKELY BOOL LBRACE program RBRACE
    (29) if -> . if ELIF condition LBRACE program RBRACE
    (30) if -> . if ELIF condition LIKELY BOOL LBRACE program RBRACE
    (31) if -> . if ELSE LBRACE program RBRACE
    (64) vardecl -> . namespace type EQUALS object
    (67) funcdecl -> . DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE
    (68) whileloop -> . WHILE condition LBRACE program RBRACE
    (69) forloop -> . FOR namespace IN object LBRACE program RBRACE
    (52) namespace -> . NAMESPACE

    RBRACE          shift and go to state 157
    IF              shift and go to state 8
    DEFINE          shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    NAMESPACE       shift and go to state 13

    namespace                      shift and go to state 9
    statement                      shift and go to state 14
    if                             shift and go to state 3
    vardecl                        shift and go to state 4
    funcdecl                       shift and go to state 5
    whileloop                      shift and go to state 6
    forloop                        shift and go to state 7

state 157

    (67) funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .

    IF              reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)
    DEFINE          reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)
    WHILE           reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)
    NAMESPACE       reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 67 (funcdecl -> DEFINE namespace LPAREN argtypes RPAREN type LBRACE program RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TIMES in state 112 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 112 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 112 resolved as shift
WARNING: shift/reduce conflict for MOD in state 112 resolved as shift
WARNING: shift/reduce conflict for POWER in state 112 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MOD in state 113 resolved as shift
WARNING: shift/reduce conflict for POWER in state 113 resolved as shift
